/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 59);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CMP_BIG_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return setImmediateInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return STR_ONE; });
/* unused harmony export ZERO */
/* unused harmony export EIGHT */
/* unused harmony export MASK */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return bytesToBigInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return writeBigUInt96BE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return iteratorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return tabulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return fancyLog; });
/* unused harmony export IDENTITY_FUNCTION */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return spawnPromise; });
const CMP_BIG_INT = (a, b) => a < b ? -1 : a > b ? 1 : 0;
function setImmediateInterval(f, ms) {
    setImmediate(f);
    return setInterval(f, ms);
}
const STR_ONE = "1";
const ZERO = BigInt(0);
const EIGHT = BigInt(8);
const MASK = BigInt(0xFF);
function bytesToBigInt(bytes) {
    if (!bytes)
        return bytes;
    let result = ZERO;
    for (const byte of bytes)
        result = (result << EIGHT) | BigInt(byte);
    return result;
}
function writeBigUInt96BE(n, buffer, offset) {
    for (let i = 0; i <= 11; ++i) {
        const byte = (n & MASK);
        buffer[offset + 11 - i] = Number(byte);
        n >>= EIGHT;
    }
}
function iteratorToArray(itr) {
    const arr = [];
    for (const item of itr)
        arr.push(item);
    return arr;
}
let currentTableLine = 0;
let maxLineLength = 0;
const ESC = Buffer.of(0o033).toString();
function tabulate(data) {
    if (currentTableLine === 0)
        console.clear();
    const keys = Object.keys(data[0]);
    const printData = new Array(data.length + 1);
    printData[0] = {};
    const widths = keys.map(key => key.length);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        printData[0][key] = key.toUpperCase();
        for (let j = 0; j < data.length; ++j) {
            const value = `${data[j][key]}`;
            const prevPrintData = printData[j + 1];
            if (prevPrintData)
                prevPrintData[key] = value;
            else {
                const dictionary = {};
                dictionary[key] = value;
                printData[j + 1] = dictionary;
            }
            const prevWidth = widths[i];
            const nextWidth = value.length;
            if (prevWidth < nextWidth)
                widths[i] = nextWidth;
        }
    }
    let toWrite = "";
    if (currentTableLine !== 0) {
        const UP = ESC + '[s' + ESC + '[' + currentTableLine + 'A';
        toWrite += UP;
    }
    currentTableLine = 0;
    for (let i = 0; i < printData.length; ++i) {
        const row = printData[i];
        let line = "";
        for (let j = 0; j < keys.length; ++j) {
            const key = keys[j];
            const padLength = widths[j];
            line += `| ${row[key].padEnd(padLength, " ")} `;
        }
        line += '|';
        const length = line.length;
        if (maxLineLength < length) {
            maxLineLength = length;
            toWrite += line;
        }
        else
            toWrite += line.padEnd(maxLineLength, " ");
        if (i === 0) {
            toWrite += "\n";
            toWrite += line.replace(/[^|]/g, "-").replace(/\|/g, "+").padEnd(maxLineLength, " ");
            ++currentTableLine;
        }
        toWrite += "\n";
        ++currentTableLine;
    }
    process.stdout.write(toWrite);
}
const IGNORE_AFTER = [
    "Module.<anonymous>",
    "Object.<anonymous>",
    "RedisClient.<anonymous>",
    "__webpack_require__",
    "functions_process",
    "processTicksAndRejections",
    "repl",
    "runMicrotasks",
];
function fancyLog(what) {
    const when = new Date().toISOString().split("T", 2)[1];
    const stack = new Error().stack.match(/    at ([^ :]+)/g).map(row => row.replace("    at ", ""));
    const hi = Math.min(...IGNORE_AFTER.map(name => stack.indexOf(name)).filter(index => index >= 0));
    const where = stack.slice(1, hi).join("() > ");
    console.log(`${ESC}[97m${when} : ${ESC}[32m${where}()\n${ESC}[39m${what}`);
}
const IDENTITY_FUNCTION = (r) => r;
async function spawnPromise(spawner) {
    const content = await new Promise((res, rej) => {
        const process = spawner();
        process.on("error", err => rej(err));
        process.stdout.on("error", err => rej(err));
        process.stderr.on("error", err => {
            fancyLog("stderr error");
            fancyLog(JSON.stringify(err));
        });
        const stdout = [];
        const stderr = [];
        process.stdout.on("data", (data) => stdout.push(data));
        process.stderr.on("data", (data) => stderr.push(data));
        process.on("close", code => {
            if (code === 0) {
                const content = Buffer.concat(stdout).toString();
                res(content);
            }
            else {
                const content = Buffer.concat(stderr).toString();
                rej(content);
            }
        });
    });
    return content;
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REDIS_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return STATIC_CONNECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SUB_CONNECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Redis; });
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redis__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);




const MAIN_HOST = "newsreduce.org";
const LOCALHOST = "127.0.0.1";
const DEFAULT_REDIS_PORT = 6379;
const DEFAULT_REDIS_DB = 0;
const REDIS_PARAMS = {
    local: {
        host: LOCALHOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    events: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    fetchSchedule: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 1,
    },
    general: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 2,
    },
    throttle: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 3,
    },
    inserts: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 4,
    },
    fetchLock: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 6,
    },
    services: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 7,
    },
};
for (const key in REDIS_PARAMS)
    REDIS_PARAMS[key].name = key;
const STATIC_CONNECTIONS = {};
const SUB_CONNECTIONS = [];
/*
 * A proxy for the redis client, which survives all sorts of
 * errors from client resets.
 */
class Redis {
    constructor(params, client) {
        this.params = params;
        this.client = client;
    }
    async tryLoop(cb) {
        for (let attempt = 0; attempt < 10; ++attempt) {
            try {
                const response = await new Promise(cb);
                return response;
            }
            catch (err) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("error on attempt", attempt.toString());
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(err);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "d"])(JSON.stringify(err));
                const oldClient = STATIC_CONNECTIONS[this.params.name];
                delete STATIC_CONNECTIONS[this.params.name];
                oldClient.quit();
                this.client = Redis.renewRedis(this.params).client;
            }
        }
        return null;
    }
    async zincrby(key, increment, member) {
        const response = await this.tryLoop((res, rej) => this.client.zincrby(key, increment, member, err => err ? rej(err) : res()));
        return response;
    }
    async zpopmaxN(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async zpopmax(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(!response || response.length === 0 ? null : response[0])));
        return response;
    }
    async spop(key) {
        const response = await this.tryLoop((res, rej) => this.client.spop(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async srem(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.srem(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async hdel(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.hdel(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async smembers(key) {
        const response = await this.tryLoop((res, rej) => this.client.smembers(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async hgetall(key) {
        const response = await this.tryLoop((res, rej) => this.client.hgetall(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async type(key) {
        const response = await this.tryLoop((res, rej) => this.client.type(key, (err, type) => err ? rej(err) : res(type)));
        return response;
    }
    async srandmember(key, batch) {
        const response = await this.tryLoop((res, rej) => this.client.srandmember(key, batch, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async setex(key, seconds = 60, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.setex(key, seconds, value, err => err ? rej(err) : res()));
        return response;
    }
    async set(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, err => err ? rej(err) : res()));
        return response;
    }
    async setpx(key, ms = 1050, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, "PX", ms, err => err ? rej(err) : res()));
        return response;
    }
    async sadd(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sadd(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async sismember(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sismember(key, member, (err, exists) => err ? rej(err) : res(!!exists)));
        return response;
    }
    async get(key) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async del(key) {
        const response = await this.tryLoop((res, rej) => this.client.del(key, err => err ? rej(err) : res()));
        return response;
    }
    async keys(pattern = "*") {
        const response = await this.tryLoop((res, rej) => this.client.keys(pattern, (err, keys) => err ? rej(err) : res(keys)));
        return response;
    }
    async hset(key, field, value) {
        const response = await this.tryLoop((res, rej) => this.client.hset(key, field, value, err => err ? rej(err) : res()));
        return response;
    }
    async eq(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response === value)));
        return response;
    }
    async publish(channel, msg) {
        const response = await this.tryLoop((res, rej) => this.client.publish(channel, msg, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    static getName(paramsOrHost) {
        return (typeof paramsOrHost === "string") ?
            paramsOrHost : paramsOrHost.name;
    }
    static computeParams(paramsOrHost) {
        const name = Redis.getName(paramsOrHost);
        let params = REDIS_PARAMS[name];
        if (!params) {
            params = Redis.defaultHostParams(paramsOrHost);
            REDIS_PARAMS[name] = params;
        }
        return params;
    }
    static renewRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        let client = STATIC_CONNECTIONS[params.name];
        let redis;
        if (!client) {
            redis = Redis.newRedis(params);
            STATIC_CONNECTIONS[params.name] = redis.client;
        }
        else {
            redis = new Redis(params, client);
        }
        return redis;
    }
    static newRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        const client = redis__WEBPACK_IMPORTED_MODULE_0___default.a.createClient({
            host: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.host : LOCALHOST,
            port: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.port : 1111,
            db: params.db,
        });
        client.on("error", (error, msg) => {
            if (msg) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(msg);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "d"])(msg);
            }
            if (error) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "d"])(JSON.stringify(error));
            }
        });
        return new Redis(params, client);
    }
    static newSub(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        const redis = this.newRedis(params);
        SUB_CONNECTIONS.push(redis.client);
        return redis;
    }
}
Redis.defaultHostParams = (host) => ({
    host,
    name: host,
    port: DEFAULT_REDIS_PORT,
    db: DEFAULT_REDIS_DB,
});


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return log; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);


const TOGGLE = false;
async function log(...args) {
    if (TOGGLE) {
        const now = Date.now();
        const varDir = await Object(_config__WEBPACK_IMPORTED_MODULE_1__[/* varDirPromise */ "k"])();
        const logFile = `${varDir}/log`;
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.appendFileSync(logFile, `${now}\t${args.join(" ")}\n`);
    }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOCALHOST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MAIN_HOSTNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return NET_AGENT_ENDPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TAR; });
/* unused harmony export FIND */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return varDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return safetyFilePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return safeMkdir; });
/* unused harmony export varDirChildPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return tmpDirPromise; });
/* unused harmony export nullDirPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return blobDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return nullFilePromise; });
/* unused harmony export myIP */
/* unused harmony export getParams */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var common_DNS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
let ENV = ["prod"];




const LOCALHOST = common_DNS__WEBPACK_IMPORTED_MODULE_3__[/* DNS */ "a"].ipv4AsIpv6("127.0.0.1");
const MAIN_HOSTNAME = "newsreduce.org";
const NET_AGENT_ENDPOINT = `http://${MAIN_HOSTNAME}:9999`;
const TAR = "tar";
const FIND = "find";
async function varDirPromise() {
    const varDir = ENV[0] === "prod" ? "/var/newsreduce" : "/var/newsreduce/test";
    await safeMkdir(varDir);
    return varDir;
}
async function safetyFilePromise() {
    const safetyFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), "safety");
    const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(safetyFile);
    if (!exists)
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(safetyFile, "0");
    return safetyFile;
}
async function safeMkdir(dir) {
    return fs__WEBPACK_IMPORTED_MODULE_0___default.a.mkdirSync(dir, { recursive: true, mode: 0o700 });
}
async function varDirChildPromise(child) {
    const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), child);
    const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(dir);
    if (!exists)
        await safeMkdir(dir);
    return dir;
}
function tmpDirPromise() {
    return varDirChildPromise("tmp");
}
function nullDirPromise() {
    return varDirChildPromise("null");
}
function blobDirPromise() {
    return varDirChildPromise("blobs");
}
async function nullFilePromise(path) {
    const safePath = path.replace(/[\/.]/g, "_");
    return `${await nullDirPromise()}/${safePath}-${Date.now()}`;
}
async function myIP() {
    const ip = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()("http://newsreduce.org:9999/ip").then(response => response.text());
    return ip;
}
let params = null;
async function getParams() {
    if (!params)
        params = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()(NET_AGENT_ENDPOINT).then(res => res.json());
    return params;
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return EVENT_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return FETCHER_BIRTH_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return FETCHER_DEATH_LOG; });
/* unused harmony export NET_AGENT_LOG */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return SCHEDULE_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return COLD_START_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return HTML_PROCESS_COMPLETE; });
/* unused harmony export WIKI_PROCESS_COMPLETE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return FETCH_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return COMPRESS_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DELETE_FILES; });
/* unused harmony export UNLOCK_FILE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return COMPRESSOR_LOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return SYNC_LOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BULK_INSERT_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FAILURE_CACHE; });
const EVENT_LOG = "event-log";
const FETCHER_BIRTH_LOG = "fetcher-birth-log";
const FETCHER_DEATH_LOG = "fetcher-death-log";
const NET_AGENT_LOG = "net-agent-log";
const SCHEDULE_COMPLETE = "schedule-complete";
const COLD_START_COMPLETE = "cold-start-complete";
const HTML_PROCESS_COMPLETE = "html-process-complete";
const WIKI_PROCESS_COMPLETE = "wiki-process-complete";
const FETCH_COMPLETE = "fetch-complete";
const COMPRESS_COMPLETE = "compress-complete";
const DELETE_FILES = "delete-files";
const UNLOCK_FILE = "unlock-file";
const COMPRESSOR_LOCK = "compressor-lock";
const SYNC_LOCK = "sync-lock";
const BULK_INSERT_COMPLETE = "bulk-insert-complete";
const FAILURE_CACHE = "failures";


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return formatToFileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fileNameToFormat; });
var FileFormat;
(function (FileFormat) {
    FileFormat[FileFormat["RAW_HTML"] = 0] = "RAW_HTML";
    FileFormat[FileFormat["RAW_HEADERS"] = 1] = "RAW_HEADERS";
    FileFormat[FileFormat["RAW_TXT"] = 2] = "RAW_TXT";
    FileFormat[FileFormat["HITS"] = 3] = "HITS";
    FileFormat[FileFormat["UNKNOWN"] = 4] = "UNKNOWN";
})(FileFormat || (FileFormat = {}));
function formatToFileName(format) {
    switch (format) {
        case FileFormat.RAW_HTML: return "raw.html";
        case FileFormat.RAW_HEADERS: return "headers.txt";
        case FileFormat.RAW_TXT: return "raw.txt";
        case FileFormat.HITS: return "hit.bin";
        default: throw `format not handled: ${format}`;
    }
}
function fileNameToFormat(fileName) {
    switch (fileName) {
        case "raw.html": return FileFormat.RAW_HTML;
        case "headers.txt": return FileFormat.RAW_HEADERS;
        case "raw.txt": return FileFormat.RAW_TXT;
        case "hit.bin": return FileFormat.HITS;
        default: return FileFormat.UNKNOWN;
    }
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SQL_PARAMS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DB_CLIENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SQL; });
/* harmony import */ var common_DNS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var mysql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var mysql__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mysql__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var common_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);







const SQL_PARAMS = {
    user: "newsreduce",
    database: "newsreduce",
    supportBigNumbers: true,
};
let DB_CLIENT = null;
let SQL_PASSWORD = null;
class SQL {
    static async db() {
        if (DB_CLIENT === null) {
            let ip = await common_DNS__WEBPACK_IMPORTED_MODULE_0__[/* DNS */ "a"].lookup(common_config__WEBPACK_IMPORTED_MODULE_2__[/* MAIN_HOSTNAME */ "c"]);
            const myIP = await common_DNS__WEBPACK_IMPORTED_MODULE_0__[/* DNS */ "a"].whoami();
            if (ip === myIP)
                ip = common_config__WEBPACK_IMPORTED_MODULE_2__[/* LOCALHOST */ "b"];
            Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("Fetching SQL config.");
            const params = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(common_config__WEBPACK_IMPORTED_MODULE_2__[/* NET_AGENT_ENDPOINT */ "d"]).then(res => res.json()).catch(_ => null);
            if (params)
                SQL_PASSWORD = params.sql;
            Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("Fetched SQL config.");
            const sqlParams = { ...SQL_PARAMS, password: SQL_PASSWORD, host: ip };
            let newClient = Object(mysql__WEBPACK_IMPORTED_MODULE_1__["createConnection"])(sqlParams);
            newClient.on("error", async (error) => {
                const oldDB = DB_CLIENT;
                DB_CLIENT = null;
                oldDB.destroy();
                await SQL.db();
                if (error) {
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(`${error.errno}`);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.code);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.message);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.name);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.sqlMessage);
                    Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "d"])(JSON.stringify(error));
                }
            });
            // Be careful for concurrency bugs creating multiple connections.
            if (DB_CLIENT === null)
                DB_CLIENT = newClient;
            else
                newClient.destroy();
        }
        return DB_CLIENT;
    }
    static async tryLoop(cb) {
        for (let attempt = 0; attempt < 10; ++attempt) {
            try {
                const response = await new Promise(cb);
                return response;
            }
            catch (err) {
                Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("error on attempt", attempt.toString());
                Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(err);
                Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "d"])("error on attempt " + attempt.toString());
                Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "d"])(JSON.stringify(err));
                const oldClient = DB_CLIENT;
                DB_CLIENT = null;
                oldClient.destroy();
                await SQL.db();
            }
        }
        return [];
    }
    static async query(template, params) {
        return this.tryLoop((res, rej) => {
            SQL.db().then(db => {
                db.query(template, params, (err, results) => {
                    if (err)
                        rej(err);
                    else
                        res(results);
                });
            });
        });
    }
    static async destroy() {
        (await SQL.db()).destroy();
    }
    static csvField(param) {
        //fancyLog("csvField " + `${param}`);
        let stringified;
        if (param === null || param === undefined)
            stringified = "NULL";
        else if (typeof param === "boolean") {
            const paramAsTinyint = param ? 1 : 0;
            stringified = `"${paramAsTinyint}"`;
        }
        else {
            const paramAsString = param.toString();
            const escapedParam = paramAsString.replace(/"/g, '\\"');
            stringified = `"${escapedParam}"`;
        }
        return stringified;
    }
    static csvRow(params) {
        return params.map(SQL.csvField).join(",");
    }
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Entity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return entityName; });
var Entity;
(function (Entity) {
    Entity[Entity["RESOURCE"] = 0] = "RESOURCE";
    Entity[Entity["HOST"] = 1] = "HOST";
    Entity[Entity["WORD"] = 2] = "WORD";
})(Entity || (Entity = {}));
function entityName(entity) {
    switch (entity) {
        case Entity.RESOURCE: return "resource";
        case Entity.HOST: return "host";
        case Entity.WORD: return "word";
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DNS; });
/* harmony import */ var dns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var dns__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dns__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);


class DNS {
    static lookup(hostname) {
        return new Promise((res, rej) => {
            dns__WEBPACK_IMPORTED_MODULE_0___default.a.lookup(hostname, (err, address, family) => {
                if (err)
                    rej(err);
                else if (family === 4)
                    res(DNS.ipv4AsIpv6(address));
                else
                    res(address);
            });
        });
    }
    static ipv4AsIpv6(ipv4) {
        return `::ffff:${ipv4}`;
    }
    static async whoami() {
        const ip = await node_fetch__WEBPACK_IMPORTED_MODULE_1___default()("http://newsreduce.org:9999/ip").then(response => response.text());
        return ip;
    }
}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */
/***/ (function(module, exports) {

module.exports = require("redis");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export entityIDs */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return write; });
/* unused harmony export sortVersions */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return lastChangedBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return lastChangedAfter; });
/* unused harmony export findVersions */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findFormats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return read; });
/* unused harmony export findLatestVersion */
/* unused harmony export readLatestVersion */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var types_FileFormat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var types_Entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1);








const FINISH = "finish";
const ERROR = "error";
const TAR_LS_PARAMS = "-atf";
const TAR_CAT_PARAMS_BEFORE_FILE = "-axf";
const TAR_CAT_PARAMS_AFTER_FILE = "-O";
async function entityIDs(entity) {
    const entityDir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])(), Object(types_Entity__WEBPACK_IMPORTED_MODULE_6__[/* entityName */ "b"])(entity));
    const files = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readdirSync(entityDir);
    return files
        .map(file => file.match(/^([0-9]+)\.tzst$/))
        .filter(match => match)
        .map(match => match[1])
        .map(BigInt);
}
/**
 * @param entityID the ID of the resource to be saved (a hash of the URL)
 * @param version    the version of the resource to be saved (milliseconds since 1970-01-01 00:00:00)
 * @param src        the source of data to be saved, either as a string of the raw data or an input stream
 *
 * @return number of bytes written
 */
async function write(entity, entityID, version, format, src) {
    const versions = await findVersions(entity, entityID);
    const found = versions.find(vAndFormat => vAndFormat[0] === version && vAndFormat[1] === format);
    if (found)
        return -1;
    const bufferFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join("/tmp", crypto__WEBPACK_IMPORTED_MODULE_2___default.a.randomBytes(30).toString("hex"));
    //if (fs.existsSync(tmpFile)) {
    //    fancyLog("file already exists: " + tmpFile);
    //    return -1;
    //}
    let bytesWritten;
    if (typeof src === "string" || src instanceof Buffer) {
        try {
            fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(bufferFile, src);
            bytesWritten = src.length;
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_7__[/* fancyLog */ "d"])("exception while writing string to file.");
            Object(common_util__WEBPACK_IMPORTED_MODULE_7__[/* fancyLog */ "d"])(JSON.stringify(e));
            bytesWritten = -1;
        }
    }
    else {
        try {
            const dst = fs__WEBPACK_IMPORTED_MODULE_0___default.a.createWriteStream(bufferFile);
            bytesWritten = await new Promise(async (res, rej) => {
                src.on(ERROR, err => rej(err));
                dst.on(ERROR, err => rej(err));
                dst.on(FINISH, () => res(dst.bytesWritten));
                src.pipe(dst);
            });
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_7__[/* fancyLog */ "d"])("exception while writing stream to file.");
            Object(common_util__WEBPACK_IMPORTED_MODULE_7__[/* fancyLog */ "d"])(JSON.stringify(e));
            bytesWritten = -1;
        }
    }
    if (bytesWritten >= 0) {
        const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* tmpDirPromise */ "j"])(), Object(types_Entity__WEBPACK_IMPORTED_MODULE_6__[/* entityName */ "b"])(entity), `${entityID}`);
        const tmpFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(dir, `${version}_${Object(types_FileFormat__WEBPACK_IMPORTED_MODULE_5__[/* formatToFileName */ "c"])(format)}`);
        await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* safeMkdir */ "h"])(dir);
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.renameSync(bufferFile, tmpFile);
    }
    else if (fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(bufferFile))
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.unlinkSync(bufferFile);
    return bytesWritten;
}
const sortVersions = (versions) => versions.sort((v1, v2) => {
    const vID1 = v1[0];
    const vID2 = v2[0];
    const cmp = vID1 - vID2;
    if (cmp !== 0)
        return cmp;
    const vFormat1 = v1[1];
    const vFormat2 = v2[1];
    return vFormat1 - vFormat2;
});
/*
 * Returns true if the path has been modified before 'ms'
 * milliseconds ago (exclusive).
 */
function lastChangedBefore(path, ms) {
    const stat = fs__WEBPACK_IMPORTED_MODULE_0___default.a.statSync(path);
    return stat.ctimeMs + ms < Date.now();
}
/*
 * Returns true if the path has been modified after 'ms'
 * milliseconds ago (inclusive).
 */
function lastChangedAfter(path, ms) {
    return !lastChangedBefore(path, ms);
}
async function findVersions(entity, entityID) {
    const blobDir = await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])();
    const compressedArc = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(blobDir, Object(types_Entity__WEBPACK_IMPORTED_MODULE_6__[/* entityName */ "b"])(entity), `${entityID}.tzst`);
    // Ignore files that are not written yet, or that have been written too recently.
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(compressedArc) || lastChangedAfter(compressedArc, 3000))
        return [];
    return (await Object(common_util__WEBPACK_IMPORTED_MODULE_7__[/* spawnPromise */ "g"])(() => Object(child_process__WEBPACK_IMPORTED_MODULE_3__["spawn"])(common_config__WEBPACK_IMPORTED_MODULE_4__[/* TAR */ "e"], [TAR_LS_PARAMS, compressedArc])))
        .split("\n") // Separate out lines.
        .map(line => line.replace(/^[0-9]+\//, "")) // Remove redundant entity ID.
        .filter(line => line.match(/^[0-9]+_/)) // Ensure this addresses a file.
        .map(line => line.split(/[/_]/, 2)) // Split on spaces and underscore.
        .map(arr => [parseInt(arr[0]), Object(types_FileFormat__WEBPACK_IMPORTED_MODULE_5__[/* fileNameToFormat */ "b"])(arr[1])]); // parse time and format pieces.
}
async function findFormats(entity, entityID, version) {
    return (await findVersions(entity, entityID))
        .filter(([time,]) => time === version)
        .map(([, format]) => format);
}
async function read(entity, entityID, version, format) {
    const blobDir = await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])();
    const compressedArc = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(blobDir, Object(types_Entity__WEBPACK_IMPORTED_MODULE_6__[/* entityName */ "b"])(entity), `${entityID}.tzst`);
    const tarPath = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(`${entityID}`, `${version}_${Object(types_FileFormat__WEBPACK_IMPORTED_MODULE_5__[/* formatToFileName */ "c"])(format)}`);
    // Ignore files that are not written yet, or that have been written too recently.
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(compressedArc) || lastChangedAfter(compressedArc, 4000))
        return null;
    return await new Promise((res, rej) => {
        const tarCat = Object(child_process__WEBPACK_IMPORTED_MODULE_3__["spawn"])(common_config__WEBPACK_IMPORTED_MODULE_4__[/* TAR */ "e"], [TAR_CAT_PARAMS_BEFORE_FILE, compressedArc, TAR_CAT_PARAMS_AFTER_FILE, tarPath]);
        const allData = [];
        tarCat.stdout.on("data", (data) => allData.push(data));
        const errData = [];
        tarCat.stderr.on("data", (data) => errData.push(data));
        tarCat.on("close", code => code === 0 ? res(Buffer.concat(allData)) : rej(Buffer.concat(errData)));
    });
}
async function findLatestVersion(entity, entityID, format) {
    const versions = await findVersions(entity, entityID);
    const sorted = versions.filter(version => version[1] === format).sort((a, b) => {
        const cmp = a[0] - b[0];
        if (cmp === 0)
            return a[1] - b[1];
        return cmp;
    });
    if (!sorted || !sorted.length)
        return -1;
    else {
        const [time,] = sorted[sorted.length - 1];
        return time;
    }
}
async function readLatestVersion(entity, entityID, format) {
    const latestVersion = await findLatestVersion(entity, entityID, format);
    if (latestVersion === -1)
        return null;
    return await read(entity, entityID, latestVersion, format);
}


/***/ }),
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SAFELY_EXIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return startProcessor; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _Redis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
/* harmony import */ var common_SQL__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);







function dangerouslyExit() {
    Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* fancyLog */ "d"])("Safety procedure activated. Exiting.");
    for (const connection of Object.values(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* STATIC_CONNECTIONS */ "c"]))
        if (connection && connection.connected)
            connection.quit();
    for (const connection of _Redis__WEBPACK_IMPORTED_MODULE_5__[/* SUB_CONNECTIONS */ "d"])
        if (connection && connection.connected)
            connection.quit();
    if (common_SQL__WEBPACK_IMPORTED_MODULE_6__[/* DB_CLIENT */ "a"])
        common_SQL__WEBPACK_IMPORTED_MODULE_6__[/* DB_CLIENT */ "a"].destroy();
    if (INTERVAL)
        clearInterval(INTERVAL);
    if (SAFETY_INTERVAL)
        clearInterval(SAFETY_INTERVAL);
}
let LOCKS = {};
async function synchronised(name, f, postcondition) {
    if (name in LOCKS)
        return;
    if (SAFELY_EXIT[0])
        dangerouslyExit();
    LOCKS[name] = true;
    f().then(() => {
        delete LOCKS[name];
        _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].renewRedis(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events).publish(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"], postcondition);
        if (SAFELY_EXIT[0])
            dangerouslyExit();
    });
}
let INTERVAL = undefined;
let SAFETY_INTERVAL = undefined;
let SAFELY_EXIT = [false];
function startProcessor(f, preconditions, postcondition, options = { interval: true, period: 2000 }) {
    const name = crypto__WEBPACK_IMPORTED_MODULE_1___default.a.randomBytes(30).toString("base64");
    if (options.interval || options.interval === undefined)
        INTERVAL = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "f"])(() => synchronised(name, f, postcondition), options.period ? options.period : 2000);
    let events;
    if (preconditions && preconditions.size > 0) {
        events = _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].newSub(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events);
        events.client.subscribe(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"]);
        events.client.on("message", (_, msg) => {
            if (preconditions.has(msg))
                synchronised(name, f, postcondition);
        });
    }
    else
        events = null;
    SAFETY_INTERVAL = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "f"])(async () => {
        const content = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(await Object(common_config__WEBPACK_IMPORTED_MODULE_3__[/* safetyFilePromise */ "i"])()).toString();
        if (content.match(/1/))
            SAFELY_EXIT[0] = true;
    }, 1000);
    return { interval: INTERVAL, events };
}


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("mysql");

/***/ }),
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(5);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);

// EXTERNAL MODULE: ./dist/main/common/config.js
var config = __webpack_require__(4);

// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__(27);

// EXTERNAL MODULE: ./dist/main/common/events.js
var events = __webpack_require__(9);

// EXTERNAL MODULE: ./dist/main/common/Redis.js
var Redis = __webpack_require__(2);

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(1);

// EXTERNAL MODULE: ./dist/main/file.js
var file = __webpack_require__(31);

// CONCATENATED MODULE: ./dist/main/common/PromisePool.js
class PromisePool {
    constructor(threads) {
        this.promises = [];
        this.threads = threads;
    }
    async register(fn) {
        this.promises.push(new Promise(fn));
        if (this.promises.length === this.threads)
            await this.flush();
    }
    async flush() {
        await Promise.all(this.promises);
        this.promises = [];
    }
}

// CONCATENATED MODULE: ./dist/main/services/compressor/functions.js









const ZSTD = "zstd";
const MK_TAR_ARGS = ["--zstd", "-cvf"];
// Only compress files not touched in past 5s.
const SAFETY_PERIOD_MS = 5000;
async function compress() {
    const redis = Redis["b" /* Redis */].renewRedis(Redis["a" /* REDIS_PARAMS */].local);
    const locked = await redis.eq(events["c" /* COMPRESSOR_LOCK */]);
    if (locked) {
        Object(util["d" /* fancyLog */])("Compressor locked while syncing.");
        return;
    }
    redis.setex(events["m" /* SYNC_LOCK */], 3600);
    Object(util["d" /* fancyLog */])("Placed sync lock.");
    const tmpDir = await Object(config["j" /* tmpDirPromise */])();
    const blobDir = await Object(config["f" /* blobDirPromise */])();
    const entities = external_fs_default.a.readdirSync(tmpDir);
    const promises = new PromisePool(50);
    let newArcs = 0;
    let oldArcs = 0;
    for (const entity of entities) {
        const tmpEntitiesDir = external_path_default.a.join(tmpDir, entity);
        const tmpEntityIDs = external_fs_default.a.readdirSync(tmpEntitiesDir).filter(dir => dir.match(/^[0-9]+$/));
        if (!tmpEntityIDs.length)
            continue;
        Object(util["d" /* fancyLog */])(`compressing ${tmpEntityIDs.length} entities.`);
        const entitiesDir = external_path_default.a.join(blobDir, entity);
        await Object(config["h" /* safeMkdir */])(entitiesDir);
        for (const entityID of tmpEntityIDs) {
            const tmpEntityDir = external_path_default.a.join(tmpEntitiesDir, entityID);
            const compressedSrc = `${tmpEntityDir}.tzst`;
            const compressedDst = external_path_default.a.join(entitiesDir, `${entityID}.tzst`);
            const arc = `${tmpEntityDir}.tar`;
            const cwd = { cwd: tmpEntitiesDir };
            await promises.register(async (res) => {
                if (Object(file["b" /* lastChangedAfter */])(tmpEntityDir, SAFETY_PERIOD_MS)) {
                    Object(util["d" /* fancyLog */])("entity modified too recently.");
                    res();
                    return;
                }
                const compressedArcExists = external_fs_default.a.existsSync(compressedDst);
                if (compressedArcExists) {
                    try {
                        await Object(util["g" /* spawnPromise */])(() => Object(external_child_process_["spawn"])(ZSTD, ["-df", compressedDst, "-o", arc]));
                    }
                    catch (e) {
                        Object(util["d" /* fancyLog */])("error decompressing");
                        Object(util["d" /* fancyLog */])(JSON.stringify(e));
                        if (external_fs_default.a.existsSync(arc))
                            external_fs_default.a.unlinkSync(arc);
                        res();
                        return;
                    }
                    try {
                        await Object(util["g" /* spawnPromise */])(() => Object(external_child_process_["spawn"])(config["e" /* TAR */], ["-uvf", arc, entityID], cwd));
                    }
                    catch (e) {
                        Object(util["d" /* fancyLog */])("error updating tar");
                        Object(util["d" /* fancyLog */])(JSON.stringify(e));
                        if (external_fs_default.a.existsSync(arc))
                            external_fs_default.a.unlinkSync(arc);
                        res();
                        return;
                    }
                    try {
                        await Object(util["g" /* spawnPromise */])(() => Object(external_child_process_["spawn"])(ZSTD, ["-f", arc, "-o", compressedSrc]));
                    }
                    catch (e) {
                        Object(util["d" /* fancyLog */])("error recompressing tar");
                        Object(util["d" /* fancyLog */])(JSON.stringify(e));
                        if (external_fs_default.a.existsSync(arc))
                            external_fs_default.a.unlinkSync(arc);
                        if (external_fs_default.a.existsSync(compressedSrc))
                            external_fs_default.a.unlinkSync(compressedSrc);
                        res();
                        return;
                    }
                    if (external_fs_default.a.existsSync(arc))
                        external_fs_default.a.renameSync(arc, await Object(config["g" /* nullFilePromise */])(arc));
                    ++oldArcs;
                }
                else {
                    try {
                        await Object(util["g" /* spawnPromise */])(() => Object(external_child_process_["spawn"])(config["e" /* TAR */], [...MK_TAR_ARGS, compressedSrc, entityID], cwd));
                    }
                    catch (e) {
                        Object(util["d" /* fancyLog */])("error creating tar");
                        Object(util["d" /* fancyLog */])(JSON.stringify(e));
                        if (external_fs_default.a.existsSync(compressedSrc))
                            external_fs_default.a.unlinkSync(compressedSrc);
                        res();
                        return;
                    }
                    ++newArcs;
                }
                if (external_fs_default.a.existsSync(compressedSrc))
                    external_fs_default.a.renameSync(compressedSrc, compressedDst);
                // Recheck last changed time, in case of concurrency bugs.
                if (external_fs_default.a.existsSync(tmpEntityDir) && Object(file["c" /* lastChangedBefore */])(tmpEntityDir, SAFETY_PERIOD_MS))
                    external_fs_default.a.renameSync(tmpEntityDir, await Object(config["g" /* nullFilePromise */])(tmpEntityDir));
                res();
            });
        }
    }
    await promises.flush();
    redis.del(events["m" /* SYNC_LOCK */]);
    Object(util["d" /* fancyLog */])("Released sync lock");
    Object(util["d" /* fancyLog */])(`${newArcs} archives created.`);
    Object(util["d" /* fancyLog */])(`${oldArcs} archives updated.`);
}

// EXTERNAL MODULE: ./dist/main/common/processor.js
var processor = __webpack_require__(45);

// CONCATENATED MODULE: ./dist/main/services/compressor/main.js



Object(processor["b" /* startProcessor */])(compress, null, events["d" /* COMPRESS_COMPLETE */]);


/***/ })
/******/ ]);