/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 57);
/******/ })
/************************************************************************/
/******/ ({

/***/ 16:
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return log; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);


async function log(...args) {
    const now = Date.now();
    const varDir = await Object(_config__WEBPACK_IMPORTED_MODULE_1__[/* varDirPromise */ "i"])();
    const logFile = `${varDir}/log`;
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.appendFileSync(logFile, `${now}\t${args.join(" ")}\n`);
}


/***/ }),

/***/ 21:
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ 30:
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),

/***/ 41:
/***/ (function(module, exports) {

module.exports = require("redis");

/***/ }),

/***/ 43:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return startProcessor; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony import */ var _Redis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);







let locks = {};
async function synchronised(name, f, postcondition) {
    if (name in locks)
        return;
    locks[name] = true;
    f().then(() => {
        delete locks[name];
        _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].renewRedis(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events).publish(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"], postcondition);
    });
}
function startProcessor(f, preconditions, postcondition, options = { interval: true, period: 2000 }) {
    let safelyExit = false;
    const name = crypto__WEBPACK_IMPORTED_MODULE_1___default.a.randomBytes(30).toString("base64");
    let interval = undefined;
    if (options.interval || options.interval === undefined)
        interval = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "f"])(() => {
            if (!safelyExit)
                synchronised(name, f, postcondition);
        }, options.period ? options.period : 2000);
    let events;
    if (preconditions && preconditions.size > 0) {
        events = _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].newRedis(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events);
        events.client.subscribe(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"]);
        events.client.on("message", (_, msg) => {
            if (preconditions.has(msg))
                synchronised(name, f, postcondition);
        });
        events.client.on("error", (_, msg) => {
            Object(_logging__WEBPACK_IMPORTED_MODULE_6__[/* log */ "a"])(msg);
            console.debug(msg);
        });
    }
    else
        events = null;
    const safetyInterval = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "f"])(async () => {
        const content = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(await Object(common_config__WEBPACK_IMPORTED_MODULE_3__[/* safetyFilePromise */ "g"])()).toString();
        if (content.match(/1/)) {
            safelyExit = true;
            clearInterval(interval);
            clearInterval(safetyInterval);
            if (events)
                events.client.quit();
            console.log("Safety procedure activated. Exiting.");
            process.exit();
        }
    }, 1000);
    return { interval, events };
}


/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return TAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FIND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return varDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return safetyFilePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return safeMkdir; });
/* unused harmony export varDirChildPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return tmpDirPromise; });
/* unused harmony export nullDirPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return blobDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return nullFilePromise; });
/* unused harmony export myIP */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
let ENV = ["prod"];



const TAR = "tar";
const FIND = "find";
async function varDirPromise() {
    const varDir = ENV[0] === "prod" ? "/var/newsreduce" : "/var/newsreduce/test";
    await safeMkdir(varDir);
    return varDir;
}
async function safetyFilePromise() {
    const safetyFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), "safety");
    const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(safetyFile);
    if (!exists)
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(safetyFile, "0");
    return safetyFile;
}
async function safeMkdir(dir) {
    return fs__WEBPACK_IMPORTED_MODULE_0___default.a.mkdirSync(dir, { recursive: true, mode: 0o700 });
}
function varDirChildPromise(child) {
    return new Promise(async (res, rej) => {
        const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), child);
        const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(dir);
        if (exists)
            res(dir);
        else
            fs__WEBPACK_IMPORTED_MODULE_0___default.a.mkdir(dir, err => err ? rej(err) : res(dir));
    });
}
function tmpDirPromise() {
    return varDirChildPromise("tmp");
}
function nullDirPromise() {
    return varDirChildPromise("null");
}
function blobDirPromise() {
    return varDirChildPromise("blobs");
}
async function nullFilePromise(path) {
    const safePath = path.replace(/[\/.]/g, "_");
    return `${await nullDirPromise()}/${safePath}-${Date.now()}`;
}
async function myIP() {
    const ip = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()("http://seanh.sh:9999/ip").then(response => response.text());
    return ip;
}


/***/ }),

/***/ 54:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REDIS_PARAMS; });
/* unused harmony export STATIC_CONNECTIONS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Redis; });
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redis__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);




const MAIN_HOST = "newsreduce.org";
const LOCALHOST = "127.0.0.1";
const DEFAULT_REDIS_PORT = 6379;
const DEFAULT_REDIS_DB = 0;
const REDIS_PARAMS = {
    local: {
        host: LOCALHOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    events: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    fetchSchedule: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 1,
    },
    general: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 2,
    },
    throttle: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 3,
    },
    inserts: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 4,
    },
    fileLock: {
        host: LOCALHOST,
        port: DEFAULT_REDIS_PORT,
        db: 5,
    },
    fetchLock: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 6,
    },
};
for (const key in REDIS_PARAMS)
    REDIS_PARAMS[key].name = key;
const STATIC_CONNECTIONS = {};
/*
 * A proxy for the redis client, which survives all sorts of
 * errors from client resets.
 */
class Redis {
    constructor(params, client) {
        this.params = params;
        this.client = client;
    }
    async tryLoop(cb) {
        for (let attempt = 0; attempt < 10; ++attempt) {
            try {
                const response = await new Promise(cb);
                return response;
            }
            catch (err) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(err);
                console.debug(err);
                const oldClient = STATIC_CONNECTIONS[this.params.name];
                delete STATIC_CONNECTIONS[this.params.name];
                oldClient.quit();
                this.client = Redis.renewRedis(this.params).client;
            }
        }
        return null;
    }
    async zincrby(key, increment, member) {
        const response = await this.tryLoop((res, rej) => this.client.zincrby(key, increment, member, err => err ? rej(err) : res()));
        return response;
    }
    async zpopmaxN(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async zpopmax(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(!response || response.length === 0 ? null : response[0])));
        return response;
    }
    async spop(key) {
        const response = await this.tryLoop((res, rej) => this.client.spop(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async srem(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.srem(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async hdel(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.hdel(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async smembers(key) {
        const response = await this.tryLoop((res, rej) => this.client.smembers(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async hgetall(key) {
        const response = await this.tryLoop((res, rej) => this.client.hgetall(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async type(key) {
        const response = await this.tryLoop((res, rej) => this.client.type(key, (err, type) => err ? rej(err) : res(type)));
        return response;
    }
    async srandmember(key, batch) {
        const response = await this.tryLoop((res, rej) => this.client.srandmember(key, batch, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async setex(key, seconds = 60, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "c"]) {
        const response = await this.tryLoop((res, rej) => this.client.setex(key, seconds, value, err => err ? rej(err) : res()));
        return response;
    }
    async set(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "c"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, err => err ? rej(err) : res()));
        return response;
    }
    async setpx(key, ms = 1050, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "c"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, "PX", ms, err => err ? rej(err) : res()));
        return response;
    }
    async sadd(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sadd(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async sismember(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sismember(key, member, (err, exists) => err ? rej(err) : res(!!exists)));
        return response;
    }
    async get(key) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async del(key) {
        const response = await this.tryLoop((res, rej) => this.client.del(key, err => err ? rej(err) : res()));
        return response;
    }
    async keys(pattern = "*") {
        const response = await this.tryLoop((res, rej) => this.client.keys(pattern, (err, keys) => err ? rej(err) : res(keys)));
        return response;
    }
    async hset(key, field, value) {
        const response = await this.tryLoop((res, rej) => this.client.hset(key, field, value, err => err ? rej(err) : res()));
        return response;
    }
    async eq(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "c"]) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response === value)));
        return response;
    }
    async publish(channel, msg) {
        const response = await this.tryLoop((res, rej) => this.client.publish(channel, msg, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    static getName(paramsOrHost) {
        return (typeof paramsOrHost === "string") ?
            paramsOrHost : paramsOrHost.name;
    }
    static computeParams(paramsOrHost) {
        const name = Redis.getName(paramsOrHost);
        let params = REDIS_PARAMS[name];
        if (!params) {
            params = Redis.defaultHostParams(paramsOrHost);
            REDIS_PARAMS[name] = params;
        }
        return params;
    }
    static renewRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        let client = STATIC_CONNECTIONS[params.name];
        let redis;
        if (!client) {
            redis = Redis.newRedis(params);
            STATIC_CONNECTIONS[params.name] = redis.client;
        }
        else {
            redis = new Redis(params, client);
        }
        return redis;
    }
    static newRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        return new Redis(params, redis__WEBPACK_IMPORTED_MODULE_0___default.a.createClient({
            host: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.host : LOCALHOST,
            port: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.port : 1111,
            db: params.db,
        }));
    }
}
Redis.defaultHostParams = (host) => ({
    host,
    name: host,
    port: DEFAULT_REDIS_PORT,
    db: DEFAULT_REDIS_DB,
});


/***/ }),

/***/ 57:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(3);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(7);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);

// EXTERNAL MODULE: ./dist/main/common/config.js
var config = __webpack_require__(5);

// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__(21);

// EXTERNAL MODULE: ./dist/main/common/logging.js
var logging = __webpack_require__(2);

// EXTERNAL MODULE: ./dist/main/common/events.js
var events = __webpack_require__(8);

// EXTERNAL MODULE: ./dist/main/common/Redis.js
var Redis = __webpack_require__(54);

// CONCATENATED MODULE: ./dist/main/services/compressor/functions.js







const ZSTD = "zstd";
const MV = "mv";
function spawnSeq(sequence, res, rej) {
    if (sequence.length === 0)
        res();
    else {
        const [head, ...tail] = sequence;
        Object(logging["a" /* log */])(JSON.stringify(head));
        const [command, cwd, args] = head;
        let process;
        if (cwd)
            process = Object(external_child_process_["spawn"])(command, args, { cwd });
        else
            process = Object(external_child_process_["spawn"])(command, args);
        const err = [];
        process.stderr.on("data", data => err.push(data));
        process.on("close", c => c === 0 ? spawnSeq(tail, res, rej) : rej(Buffer.concat(err).toString()));
    }
}
function isEntityLocked(entityID) {
    return Redis["b" /* Redis */].renewRedis(Redis["a" /* REDIS_PARAMS */].fileLock).eq(entityID);
}
async function compress() {
    const locked = await Redis["b" /* Redis */].renewRedis(Redis["a" /* REDIS_PARAMS */].general).eq(events["c" /* COMPRESSOR_LOCK */]);
    if (locked)
        return;
    const tmpDir = await Object(config["h" /* tmpDirPromise */])();
    const entities = external_fs_default.a.readdirSync(tmpDir);
    const promises = [];
    for (const entity of entities) {
        const entitiesDir = external_path_default.a.join(tmpDir, entity);
        const entityIDs = external_fs_default.a.readdirSync(entitiesDir).filter(dir => dir.match(/^[0-9]+$/));
        for (const entityID of entityIDs) {
            if (await isEntityLocked(entityID))
                continue;
            console.log(entityID);
            const entityDir = external_path_default.a.join(entitiesDir, entityID);
            const compressedArc = `${entityDir.replace(/\/tmp\//, "/blobs/")}.tzst`;
            const arc = `${entityDir}.tar`;
            const compressedArcExists = external_fs_default.a.existsSync(compressedArc);
            if (compressedArcExists) {
                promises.push(new Promise(async (res, rej) => spawnSeq([
                    [ZSTD, undefined, ["-df", compressedArc, "-o", arc]],
                    [config["c" /* TAR */], entitiesDir, ["-uvf", arc, entityID]],
                    [ZSTD, undefined, ["-f", arc, "-o", compressedArc]],
                    [MV, undefined, [arc, await Object(config["e" /* nullFilePromise */])(arc)]],
                    [MV, undefined, [entityDir, await Object(config["e" /* nullFilePromise */])(entityDir)]],
                ], res, rej)));
            }
            else {
                await Object(config["f" /* safeMkdir */])(external_path_default.a.dirname(compressedArc));
                promises.push(new Promise(async (res, rej) => spawnSeq([
                    [config["c" /* TAR */], entitiesDir, ["--zstd", "-cvf", compressedArc, entityID]],
                    [MV, undefined, [entityDir, await Object(config["e" /* nullFilePromise */])(entityDir)]],
                ], res, rej)));
            }
        }
    }
    await Promise.all(promises);
}

// EXTERNAL MODULE: ./dist/main/common/processor.js
var processor = __webpack_require__(43);

// CONCATENATED MODULE: ./dist/main/services/compressor/main.js



Object(processor["a" /* startProcessor */])(compress, null, events["d" /* COMPRESS_COMPLETE */]);


/***/ }),

/***/ 6:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CMP_BIG_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return setImmediateInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return STR_ONE; });
/* unused harmony export ZERO */
/* unused harmony export EIGHT */
/* unused harmony export MASK */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return bytesToBigInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return writeBigUInt96BE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return iteratorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IDENTITY_FUNCTION; });
const CMP_BIG_INT = (a, b) => a < b ? -1 : a > b ? 1 : 0;
function setImmediateInterval(f, ms) {
    setImmediate(f);
    return setInterval(f, ms);
}
const STR_ONE = "1";
const ZERO = BigInt(0);
const EIGHT = BigInt(8);
const MASK = BigInt(0xFF);
function bytesToBigInt(bytes) {
    if (!bytes)
        return bytes;
    let result = ZERO;
    for (const byte of bytes)
        result = (result << EIGHT) | BigInt(byte);
    return result;
}
function writeBigUInt96BE(n, buffer, offset) {
    for (let i = 0; i <= 11; ++i) {
        const byte = (n & MASK);
        buffer[offset + 11 - i] = Number(byte);
        n >>= EIGHT;
    }
}
function iteratorToArray(itr) {
    const arr = [];
    for (const item of itr)
        arr.push(item);
    return arr;
}
const IDENTITY_FUNCTION = (r) => r;


/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return EVENT_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FETCHER_BIRTH_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return FETCHER_DEATH_LOG; });
/* unused harmony export NET_AGENT_LOG */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return SCHEDULE_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return COLD_START_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return HTML_PROCESS_COMPLETE; });
/* unused harmony export WIKI_PROCESS_COMPLETE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return FETCH_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return COMPRESS_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DELETE_FILES; });
/* unused harmony export UNLOCK_FILE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return COMPRESSOR_LOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BULK_INSERT_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return INSERT_CACHE; });
const EVENT_LOG = "event-log";
const FETCHER_BIRTH_LOG = "fetcher-birth-log";
const FETCHER_DEATH_LOG = "fetcher-death-log";
const NET_AGENT_LOG = "net-agent-log";
const SCHEDULE_COMPLETE = "schedule-complete";
const COLD_START_COMPLETE = "cold-start-complete";
const HTML_PROCESS_COMPLETE = "html-process-complete";
const WIKI_PROCESS_COMPLETE = "wiki-process-complete";
const FETCH_COMPLETE = "fetch-complete";
const COMPRESS_COMPLETE = "compress-complete";
const DELETE_FILES = "delete-files";
const UNLOCK_FILE = "unlock-file";
const COMPRESSOR_LOCK = "compressor-lock";
const BULK_INSERT_COMPLETE = "bulk-insert-complete";
const INSERT_CACHE = "inserted";


/***/ })

/******/ });