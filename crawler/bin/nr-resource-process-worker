/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 78);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CMP_BIG_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return setImmediateInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return STR_ONE; });
/* unused harmony export BIGINT_ZERO */
/* unused harmony export BIGINT_EIGHT */
/* unused harmony export BIGINT_MASK */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return bytesToBigInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return bytesToNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return writeBigUInt96BE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return writeAnyNumberBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return iteratorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return tabulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return fancyLog; });
/* unused harmony export IDENTITY_FUNCTION */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return spawnPromise; });
/* unused harmony export sleep */
const CMP_BIG_INT = (a, b) => a < b ? -1 : a > b ? 1 : 0;
function setImmediateInterval(f, ms) {
    setImmediate(f);
    return setInterval(f, ms);
}
const STR_ONE = "1";
const BIGINT_ZERO = BigInt(0);
const BIGINT_EIGHT = BigInt(8);
const BIGINT_MASK = BigInt(0xFF);
function bytesToBigInt(bytes) {
    if (!bytes)
        return bytes;
    let result = BIGINT_ZERO;
    for (const byte of bytes)
        result = (result << BIGINT_EIGHT) | BigInt(byte);
    return result;
}
function bytesToNumber(bytes) {
    if (!bytes)
        return bytes;
    let result = 0;
    for (const byte of bytes)
        result = (result << 8) | byte;
    return result;
}
function writeBigUInt96BE(n, buffer = Buffer.alloc(12), offset = 0) {
    writeAnyNumberBE(n, buffer, offset, 12);
    return buffer;
}
function writeAnyNumberBE(n, buffer, offset, bytes) {
    let bigintN = BigInt(n);
    for (let i = 0; i < bytes; ++i) {
        const byte = (bigintN & BIGINT_MASK);
        buffer[offset + bytes - 1 - i] = Number(byte);
        bigintN >>= BIGINT_EIGHT;
    }
    return buffer;
}
function iteratorToArray(itr) {
    const arr = [];
    for (const item of itr)
        arr.push(item);
    return arr;
}
let currentTableLine = 0;
let maxLineLength = 0;
const ESC = Buffer.of(0o033).toString();
function tabulate(data) {
    if (currentTableLine === 0)
        console.clear();
    const keys = Object.keys(data[0]);
    const printData = new Array(data.length + 1);
    printData[0] = {};
    const widths = keys.map(key => key.length);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        printData[0][key] = key.toUpperCase();
        for (let j = 0; j < data.length; ++j) {
            const value = `${data[j][key]}`;
            const prevPrintData = printData[j + 1];
            if (prevPrintData)
                prevPrintData[key] = value;
            else {
                const dictionary = {};
                dictionary[key] = value;
                printData[j + 1] = dictionary;
            }
            const prevWidth = widths[i];
            const nextWidth = value.length;
            if (prevWidth < nextWidth)
                widths[i] = nextWidth;
        }
    }
    let toWrite = "";
    if (currentTableLine !== 0) {
        const UP = ESC + '[s' + ESC + '[' + currentTableLine + 'A';
        toWrite += UP;
    }
    currentTableLine = 0;
    for (let i = 0; i < printData.length; ++i) {
        const row = printData[i];
        let line = "";
        for (let j = 0; j < keys.length; ++j) {
            const key = keys[j];
            const padLength = widths[j];
            line += `| ${row[key].padEnd(padLength, " ")} `;
        }
        line += '|';
        const length = line.length;
        if (maxLineLength < length) {
            maxLineLength = length;
            toWrite += line;
        }
        else
            toWrite += line.padEnd(maxLineLength, " ");
        if (i === 0) {
            toWrite += "\n";
            toWrite += line.replace(/[^|]/g, "-").replace(/\|/g, "+").padEnd(maxLineLength, " ");
            ++currentTableLine;
        }
        toWrite += "\n";
        ++currentTableLine;
    }
    process.stdout.write(toWrite);
}
const IGNORE_AFTER = [
    "Module.<anonymous>",
    "Object.<anonymous>",
    "RedisClient.<anonymous>",
    "__webpack_require__",
    "functions_process",
    "processTicksAndRejections",
    "repl",
    "runMicrotasks",
];
function fancyLog(what) {
    const when = new Date().toISOString().split("T", 2)[1];
    const stack = new Error().stack.match(/    at ([^ :]+)/g).map(row => row.replace("    at ", ""));
    const hi = Math.min(...IGNORE_AFTER.map(name => stack.indexOf(name)).filter(index => index >= 0));
    const where = stack.slice(1, hi).join("() > ");
    console.log(`${ESC}[97m${when} : ${ESC}[32m${where}()\n${ESC}[39m${what}`);
}
const IDENTITY_FUNCTION = (r) => r;
async function spawnPromise(spawner) {
    const content = await new Promise((res, rej) => {
        const process = spawner();
        process.on("error", err => rej(err));
        process.stdout.on("error", err => rej(err));
        process.stderr.on("error", err => {
            fancyLog("stderr error");
            fancyLog(JSON.stringify(err));
        });
        const stdout = [];
        const stderr = [];
        process.stdout.on("data", (data) => stdout.push(data));
        process.stderr.on("data", (data) => stderr.push(data));
        process.on("close", code => {
            if (code === 0) {
                const content = Buffer.concat(stdout);
                res(content);
            }
            else {
                const content = Buffer.concat(stderr);
                rej(content);
            }
        });
    });
    return content;
}
function sleep(ms) {
    return new Promise(res => {
        setTimeout(res, ms);
    });
}


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ DBObject_DBObject; });

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(14);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);

// CONCATENATED MODULE: ./dist/main/common/hashing.js

function checksum(content) {
    return external_crypto_default.a.createHash("sha384").update(content).digest().toString("base64");
}
function defaultHash(prefix, str) {
    return external_crypto_default.a.createHash("sha3-256").update(`${prefix}:${str.toString()}`).digest().slice(0, 12);
}

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./dist/main/common/Redis.js
var Redis = __webpack_require__(2);

// EXTERNAL MODULE: ./dist/main/common/SQL.js
var SQL = __webpack_require__(12);

// EXTERNAL MODULE: ./dist/main/types/GenericConstructor.js
var GenericConstructor = __webpack_require__(71);

// CONCATENATED MODULE: ./dist/main/types/DBObject.js





const ESCAPE = "ESCAPED BY '\\\\'";
const ENCLOSE = `ENCLOSED BY '"'`;
const FIELD_TERM = "FIELDS TERMINATED BY ','";
const LINE_TERM = "LINES TERMINATED BY '\\n'";
class DBObject_DBObject extends GenericConstructor["a" /* GenericConstructor */] {
    getIDBytes() {
        const suffix = this.hashSuffix();
        return suffix === null ? null : defaultHash(this.table(), suffix);
    }
    getID() {
        const idBytes = this.getIDBytes();
        return idBytes ? Object(util["c" /* bytesToBigInt */])(idBytes) : null;
    }
    getInsertStatement() {
        const cols = this.insertCols().map(col => "`" + col + "`").join(", ");
        return `insert ignore into ${this.table()}(${cols}) values ?`;
    }
    getSingularInsertParams() {
        return [[this.getInsertParams()]];
    }
    getDeps() {
        return [];
    }
    async singularInsert(options = { recursive: false }) {
        const promises = [];
        // No circular dependencies allowed.
        if (options.recursive) {
            const deps = this.getDeps();
            for (const insert of deps.map(dep => dep.singularInsert(options)))
                promises.push(insert);
        }
        const query = this.getInsertStatement();
        const params = this.getSingularInsertParams();
        promises.push(SQL["b" /* SQL */].query(query, params));
        await Promise.all(promises);
    }
    async bulkInsert(csvFile) {
        //fancyLog(csvFile);
        if (!csvFile)
            return;
        const cols = this.insertCols().map(col => `\`${col}\``).join(",");
        const table = this.table();
        const query = `LOAD DATA INFILE ? ` +
            `IGNORE INTO TABLE \`${table}\` ` +
            `${FIELD_TERM} ${ENCLOSE} ${ESCAPE} ${LINE_TERM} (${cols})`;
        //fancyLog(query);
        await SQL["b" /* SQL */].query(query, [csvFile]);
    }
    static stringifyBigIntsInPlace(obj) {
        if (typeof obj === "object") {
            for (const key in obj) {
                const value = obj[key];
                if (typeof value === "bigint")
                    obj[key] = value.toString();
                else
                    DBObject_DBObject.stringifyBigIntsInPlace(value);
            }
        }
    }
    asCSVRow() {
        return SQL["b" /* SQL */].csvRow(this.getInsertParams());
    }
    async enqueueInsert(options = { recursive: false }) {
        const promises = [];
        // No circular dependencies allowed.
        if (options.recursive)
            for (const dep of this.getDeps())
                promises.push(dep.enqueueInsert(options));
        const payload = this.asCSVRow();
        promises.push(Redis["b" /* Redis */].renewRedis(Redis["a" /* REDIS_PARAMS */].inserts).sadd(this.table(), payload));
        await Promise.all(promises);
    }
    async singularSelect(columns) {
        let cols;
        if (columns)
            cols = columns.map(column => "`" + column + "`").join(", ");
        else
            cols = "*";
        const query = `select ${cols} from ${this.table()} where ${this.idCol()} = ?`;
        return await SQL["b" /* SQL */].query(query, [this.getID()])[0];
    }
    async bulkSelect(ids, columns) {
        if (!ids || ids.length === 0)
            return [];
        const idCol = this.idCol();
        const query = `select ${idCol}, ${columns.join(", ")} from ${this.table()} where ${idCol} in ?`;
        const response = await SQL["b" /* SQL */].query(query, [[ids]]);
        return response;
    }
    idCol() {
        return "id";
    }
    hashSuffix() {
        return null;
    }
    static forTable(table) {
        const DBObjectT = __webpack_require__(53)(`./${table}`)[table];
        return new DBObjectT();
    }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REDIS_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return STATIC_CONNECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SUB_CONNECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Redis; });
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redis__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);




const MAIN_HOST = "newsreduce.org";
const LOCALHOST = "127.0.0.1";
const DEFAULT_REDIS_PORT = 6379;
const DEFAULT_REDIS_DB = 0;
const REDIS_PARAMS = {
    local: {
        host: LOCALHOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    events: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: DEFAULT_REDIS_DB,
    },
    fetchSchedule: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 1,
    },
    general: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 2,
    },
    throttle: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 3,
    },
    inserts: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 4,
    },
    fetchLock: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 6,
    },
    services: {
        host: MAIN_HOST,
        port: DEFAULT_REDIS_PORT,
        db: 7,
    },
};
for (const key in REDIS_PARAMS)
    REDIS_PARAMS[key].name = key;
const STATIC_CONNECTIONS = {};
const SUB_CONNECTIONS = [];
/*
 * A proxy for the redis client, which survives all sorts of
 * errors from client resets.
 */
class Redis {
    constructor(params, client) {
        this.params = params;
        this.client = client;
    }
    async tryLoop(cb) {
        for (let attempt = 0; attempt < 10; ++attempt) {
            try {
                const response = await new Promise(cb);
                return response;
            }
            catch (err) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("error on attempt", attempt.toString());
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(err);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "e"])(JSON.stringify(err));
                const oldClient = STATIC_CONNECTIONS[this.params.name];
                delete STATIC_CONNECTIONS[this.params.name];
                if (oldClient)
                    oldClient.quit();
                this.client = Redis.renewRedis(this.params).client;
            }
        }
        return null;
    }
    async zincrby(key, increment, member) {
        const response = await this.tryLoop((res, rej) => this.client.zincrby(key, increment, member, err => err ? rej(err) : res()));
        return response;
    }
    async zpopmaxN(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async zpopmax(key, count) {
        const response = await this.tryLoop((res, rej) => this.client.zpopmax([key, count], (err, response) => err ? rej(err) : res(!response || response.length === 0 ? null : response[0])));
        return response;
    }
    async spop(key) {
        const response = await this.tryLoop((res, rej) => this.client.spop(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async srem(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.srem(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async hdel(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.hdel(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async smembers(key) {
        const response = await this.tryLoop((res, rej) => this.client.smembers(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async hgetall(key) {
        const response = await this.tryLoop((res, rej) => this.client.hgetall(key, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async type(key) {
        const response = await this.tryLoop((res, rej) => this.client.type(key, (err, type) => err ? rej(err) : res(type)));
        return response;
    }
    async srandmember(key, batch) {
        const response = await this.tryLoop((res, rej) => this.client.srandmember(key, batch, (err, members) => err ? rej(err) : res(members)));
        return response;
    }
    async setex(key, seconds = 60, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.setex(key, seconds, value, err => err ? rej(err) : res()));
        return response;
    }
    async set(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, err => err ? rej(err) : res()));
        return response;
    }
    async setpx(key, ms = 1050, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.set(key, value, "PX", ms, err => err ? rej(err) : res()));
        return response;
    }
    async sadd(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sadd(key, member, err => err ? rej(err) : res()));
        return response;
    }
    async sismember(key, member) {
        const response = await this.tryLoop((res, rej) => this.client.sismember(key, member, (err, exists) => err ? rej(err) : res(!!exists)));
        return response;
    }
    async get(key) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    async del(key) {
        const response = await this.tryLoop((res, rej) => this.client.del(key, err => err ? rej(err) : res()));
        return response;
    }
    async keys(pattern = "*") {
        const response = await this.tryLoop((res, rej) => this.client.keys(pattern, (err, keys) => err ? rej(err) : res(keys)));
        return response;
    }
    async hset(key, field, value) {
        const response = await this.tryLoop((res, rej) => this.client.hset(key, field, value, err => err ? rej(err) : res()));
        return response;
    }
    async eq(key, value = _util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]) {
        const response = await this.tryLoop((res, rej) => this.client.get(key, (err, response) => err ? rej(err) : res(response === value)));
        return response;
    }
    async publish(channel, msg) {
        const response = await this.tryLoop((res, rej) => this.client.publish(channel, msg, (err, response) => err ? rej(err) : res(response)));
        return response;
    }
    static getName(paramsOrHost) {
        return (typeof paramsOrHost === "string") ?
            paramsOrHost : paramsOrHost.name;
    }
    static computeParams(paramsOrHost) {
        const name = Redis.getName(paramsOrHost);
        let params = REDIS_PARAMS[name];
        if (!params) {
            params = Redis.defaultHostParams(paramsOrHost);
            REDIS_PARAMS[name] = params;
        }
        return params;
    }
    static renewRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        let client = STATIC_CONNECTIONS[params.name];
        let redis;
        if (!client) {
            redis = Redis.newRedis(params);
            STATIC_CONNECTIONS[params.name] = redis.client;
        }
        else {
            redis = new Redis(params, client);
        }
        return redis;
    }
    static newRedis(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        const client = redis__WEBPACK_IMPORTED_MODULE_0___default.a.createClient({
            host: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.host : LOCALHOST,
            port: common_config__WEBPACK_IMPORTED_MODULE_1__[/* ENV */ "a"][0] === "prod" ? params.port : 1111,
            db: params.db,
        });
        client.on("error", (error, msg) => {
            if (msg) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(msg);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "e"])(msg);
            }
            if (error) {
                Object(_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error);
                Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* fancyLog */ "e"])(JSON.stringify(error));
            }
        });
        return new Redis(params, client);
    }
    static newSub(paramsOrHost) {
        const params = this.computeParams(paramsOrHost);
        const redis = this.newRedis(params);
        SUB_CONNECTIONS.push(redis.client);
        return redis;
    }
}
Redis.defaultHostParams = (host) => ({
    host,
    name: host,
    port: DEFAULT_REDIS_PORT,
    db: DEFAULT_REDIS_DB,
});


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleHashObject", function() { return SimpleHashObject; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class SimpleHashObject extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(arg) {
        if (arg === null || arg === undefined)
            super();
        else if (typeof arg === "string" || arg instanceof Buffer)
            super({ value: arg });
        else
            super(arg);
    }
    hashSuffix() {
        return this.value.toString();
    }
    insertCols() {
        return ["id", "value"];
    }
    getInsertParams() {
        return [this.getID(), this.value];
    }
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOCALHOST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MAIN_HOSTNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return NET_AGENT_ENDPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TAR; });
/* unused harmony export FIND */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return varDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return safetyFilePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return safeMkdir; });
/* unused harmony export varDirChildPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return tmpDirPromise; });
/* unused harmony export nullDirPromise */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return blobDirPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return nullFilePromise; });
/* unused harmony export myIP */
/* unused harmony export getParams */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var common_DNS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
let ENV = ["prod"];




const LOCALHOST = common_DNS__WEBPACK_IMPORTED_MODULE_3__[/* DNS */ "a"].ipv4AsIpv6("127.0.0.1");
const MAIN_HOSTNAME = "newsreduce.org";
const NET_AGENT_ENDPOINT = `http://${MAIN_HOSTNAME}:9999`;
const TAR = "tar";
const FIND = "find";
async function varDirPromise() {
    const varDir = ENV[0] === "prod" ? "/var/newsreduce" : "/var/newsreduce/test";
    await safeMkdir(varDir);
    return varDir;
}
async function safetyFilePromise() {
    const safetyFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), "safety");
    const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(safetyFile);
    if (!exists)
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(safetyFile, "0");
    return safetyFile;
}
async function safeMkdir(dir) {
    return fs__WEBPACK_IMPORTED_MODULE_0___default.a.mkdirSync(dir, { recursive: true, mode: 0o700 });
}
async function varDirChildPromise(child) {
    const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await varDirPromise(), child);
    const exists = fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(dir);
    if (!exists)
        await safeMkdir(dir);
    return dir;
}
function tmpDirPromise() {
    return varDirChildPromise("tmp");
}
function nullDirPromise() {
    return varDirChildPromise("null");
}
function blobDirPromise() {
    return varDirChildPromise("blobs");
}
async function nullFilePromise(path) {
    const safePath = path.replace(/[\/.]/g, "_");
    return `${await nullDirPromise()}/${safePath}-${Date.now()}`;
}
async function myIP() {
    const ip = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()("http://newsreduce.org:9999/ip").then(response => response.text());
    return ip;
}
let params = null;
async function getParams() {
    if (!params)
        params = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()(NET_AGENT_ENDPOINT).then(res => res.json());
    return params;
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return log; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);


const TOGGLE = false;
async function log(...args) {
    if (TOGGLE) {
        const now = Date.now();
        const varDir = await Object(_config__WEBPACK_IMPORTED_MODULE_1__[/* varDirPromise */ "k"])();
        const logFile = `${varDir}/log`;
        fs__WEBPACK_IMPORTED_MODULE_0___default.a.appendFileSync(logFile, `${now}\t${args.join(" ")}\n`);
    }
}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceURL", function() { return ResourceURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceID", function() { return ResourceID; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURLQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var types_objects_ResourceURLPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var types_objects_Host__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var file__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var types_Entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var common_logging__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var common_Redis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2);
/* harmony import */ var common_events__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);
/* harmony import */ var _ResourceVersion__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);











const URL_ENCODING = "utf8";
const PORT_BASE = 10;
const URL = /^http(s)?:\/\/([^\/:?#]+)(:\d+)?(\/[^?#]*)?(\?[^#]*)?(#.*)?$/;
class ResourceURL extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(arg) {
        if (arg === null || arg === undefined)
            super();
        else if (typeof arg === "string") {
            const groups = arg.match(URL);
            if (!groups)
                throw new Error(`url parse error for: ${arg}`);
            const ssl = !!groups[1];
            const portStr = groups[3];
            const port = portStr ?
                parseInt(portStr.substr(1)) : ssl ? 443 : 80;
            const path = groups[4] ? groups[4] : "";
            const query = groups[5] ? groups[5].substr(1) : "";
            const host = groups[2];
            if (host === null || host === undefined)
                throw new Error(`invalid url (no host): ${arg}`);
            if (port === null || port === undefined)
                throw new Error(`invalid url (no port): ${arg}`);
            if (path === null || path === undefined)
                throw new Error(`invalid url (no path): ${arg}`);
            if (query === null || query === undefined)
                throw new Error(`invalid url (no query): ${arg}`);
            super({
                ssl,
                host: new types_objects_Host__WEBPACK_IMPORTED_MODULE_3__["Host"]({ name: host }),
                port,
                path: new types_objects_ResourceURLPath__WEBPACK_IMPORTED_MODULE_2__["ResourceURLPath"]({ value: path }),
                query: new types_objects_ResourceURLQuery__WEBPACK_IMPORTED_MODULE_1__["ResourceURLQuery"]({ value: query }),
            });
        }
        else {
            if (arg.host === null || arg.host === undefined)
                throw new Error(`invalid url (no host): ${JSON.stringify(arg)}`);
            if (arg.port === null || arg.port === undefined)
                throw new Error(`invalid url (no port): ${JSON.stringify(arg)}`);
            if (arg.path === null || arg.path === undefined)
                throw new Error(`invalid url (no path): ${JSON.stringify(arg)}`);
            if (arg.query === null || arg.query === undefined)
                throw new Error(`invalid url (no query): ${JSON.stringify(arg)}`);
            super({
                ssl: !!arg.ssl,
                host: new types_objects_Host__WEBPACK_IMPORTED_MODULE_3__["Host"]({ name: arg.host }),
                port: arg.port,
                path: new types_objects_ResourceURLPath__WEBPACK_IMPORTED_MODULE_2__["ResourceURLPath"]({ value: arg.path }),
                query: new types_objects_ResourceURLQuery__WEBPACK_IMPORTED_MODULE_1__["ResourceURLQuery"]({ value: arg.query }),
            });
        }
    }
    toURL() {
        if (!this.port)
            Object(common_logging__WEBPACK_IMPORTED_MODULE_6__[/* log */ "a"])("error", "port should be truthy in toURL", JSON.stringify(this));
        const protocol = this.ssl ? "https://" : "http://";
        let length = protocol.length;
        let portString = "";
        if (this.port === 443) {
            if (!this.ssl)
                portString = "443";
        }
        else if (this.port === 80) {
            if (this.ssl)
                portString = "80";
        }
        else if (this.port) {
            portString = this.port.toString(PORT_BASE);
        }
        else {
            common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* REDIS_PARAMS */ "a"].general)
                .zincrby(common_events__WEBPACK_IMPORTED_MODULE_8__[/* FAILURE_CACHE */ "g"], 1, "port gen issue " + JSON.stringify(this));
        }
        length += portString ? 1 : 0;
        length += Buffer.byteLength(portString, URL_ENCODING);
        length += Buffer.byteLength(this.host.name, URL_ENCODING);
        length += Buffer.byteLength(this.path.value, URL_ENCODING);
        length += Buffer.byteLength(this.query.value, URL_ENCODING);
        length += this.query.value ? 1 : 0;
        const url = Buffer.alloc(length);
        let i = 0;
        i += url.write(protocol, i, URL_ENCODING);
        i += url.write(this.host.name, i, URL_ENCODING);
        if (portString)
            i += url.write(":", i, URL_ENCODING);
        i += url.write(portString, i, URL_ENCODING);
        i += url.write(this.path.value, i, URL_ENCODING);
        if (this.query.value)
            i += url.write("?", i, URL_ENCODING);
        i += url.write(this.query.value, i, URL_ENCODING);
        return url.toString(URL_ENCODING);
    }
    hashSuffix() {
        return this.toURL();
    }
    insertCols() {
        return ["id", "ssl", "host", "port", "path", "query"];
    }
    getInsertParams() {
        const id = this.getID();
        const host = this.host.getID();
        const path = this.path.getID();
        const query = this.query.getID();
        return [id, this.ssl, host, this.port, path, query];
    }
    table() {
        return "ResourceURL";
    }
    getDeps() {
        return [this.host, this.path, this.query];
    }
    async writeVersion(time, type, input) {
        const id = this.getID();
        let bytesWritten = -1;
        if (typeof input === "string" || input instanceof Buffer) {
            let i = 0;
            for (i = 0; i < 10 && bytesWritten < 0; ++i)
                bytesWritten = await Object(file__WEBPACK_IMPORTED_MODULE_4__[/* write */ "h"])(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* Entity */ "a"].RESOURCE, id, time, type, input);
            if (i > 1 && bytesWritten >= 0) {
                Object(common_util__WEBPACK_IMPORTED_MODULE_9__[/* fancyLog */ "e"])(`wrote ${bytesWritten}b to ` +
                    `${Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* Entity */ "a"].RESOURCE)} ${id} ` +
                    `(${type.filename}, v${time}) on attempt ${i}.`);
            }
        }
        else
            bytesWritten = await Object(file__WEBPACK_IMPORTED_MODULE_4__[/* write */ "h"])(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* Entity */ "a"].RESOURCE, id, time, type, input);
        if (bytesWritten >= 0)
            new _ResourceVersion__WEBPACK_IMPORTED_MODULE_10__["ResourceVersion"]({
                resource: this,
                time,
                type,
                length: bytesWritten,
            }).enqueueInsert({ recursive: true });
        return bytesWritten;
    }
    isFetchLocked() {
        return common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* REDIS_PARAMS */ "a"].fetchLock).eq(this.toURL());
    }
    async setFetchLock() {
        await common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* REDIS_PARAMS */ "a"].fetchLock).setex(this.toURL(), 300);
    }
    isInvalid() {
        return this.ssl === null
            || this.ssl === undefined
            || this.host === null
            || this.host === undefined
            || this.port === null
            || this.port === undefined
            || this.path === null
            || this.path === undefined
            || this.query === null
            || this.query === undefined;
    }
    isValid() {
        return !this.isInvalid();
    }
    async read(time, format) {
        try {
            return await Object(file__WEBPACK_IMPORTED_MODULE_4__[/* read */ "f"])(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* Entity */ "a"].RESOURCE, this.getID(), time, format);
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_9__[/* fancyLog */ "e"])(JSON.stringify(e));
            return null;
        }
    }
    async stream(time, format) {
        try {
            return await Object(file__WEBPACK_IMPORTED_MODULE_4__[/* stream */ "g"])(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* Entity */ "a"].RESOURCE, this.getID(), time, format);
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_9__[/* fancyLog */ "e"])(JSON.stringify(e));
            return null;
        }
    }
    static async popForProcessing() {
        const url = await common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_7__[/* REDIS_PARAMS */ "a"].general).spop("html");
        if (!url)
            return null;
        return new ResourceURL(url);
    }
    static async registerVersionIfSuccessful(resource, time, type, length) {
        if (length >= 0)
            await new _ResourceVersion__WEBPACK_IMPORTED_MODULE_10__["ResourceVersion"]({ resource, time, type, length })
                .enqueueInsert({ recursive: true });
    }
}
class ResourceID extends ResourceURL {
    constructor(id) {
        super();
        this.id = id;
    }
    getID() {
        return this.id;
    }
    async enqueueInsert() { }
}


/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Entity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return entityName; });
var Entity;
(function (Entity) {
    Entity[Entity["RESOURCE"] = 0] = "RESOURCE";
    Entity[Entity["HOST"] = 1] = "HOST";
    Entity[Entity["WORD"] = 2] = "WORD";
})(Entity || (Entity = {}));
function entityName(entity) {
    switch (entity) {
        case Entity.RESOURCE: return "resource";
        case Entity.HOST: return "host";
        case Entity.WORD: return "word";
    }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceVersionType", function() { return ResourceVersionType; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class ResourceVersionType extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(arg) {
        if (!arg)
            super();
        else if (typeof arg === "string")
            super({ filename: arg });
        else
            super(arg);
    }
    insertCols() {
        return ["id", "filename"];
    }
    getInsertParams() {
        const params = [this.getID(), this.filename];
        return params;
    }
    table() {
        return "ResourceVersionType";
    }
    hashSuffix() {
        return this.filename;
    }
}
ResourceVersionType.RAW_HTML_FILE = "raw.html";
ResourceVersionType.RAW_HTML = new ResourceVersionType({ filename: ResourceVersionType.RAW_HTML_FILE });
ResourceVersionType.RAW_ZIP_FILE = "raw.zip";
ResourceVersionType.RAW_ZIP = new ResourceVersionType({ filename: ResourceVersionType.RAW_ZIP_FILE });
ResourceVersionType.WORD_EMBEDDINGS_FILE = "word-embeddings.bin";
ResourceVersionType.WORD_EMBEDDINGS = new ResourceVersionType({ filename: ResourceVersionType.WORD_EMBEDDINGS_FILE });
ResourceVersionType.RAW_WORDS_TXT_FILE = "raw-words.txt";
ResourceVersionType.RAW_WORDS_TXT = new ResourceVersionType({ filename: ResourceVersionType.RAW_WORDS_TXT_FILE });
ResourceVersionType.RAW_LINKS_TXT_FILE = "raw-links.txt";
ResourceVersionType.RAW_LINKS_TXT = new ResourceVersionType({ filename: ResourceVersionType.RAW_LINKS_TXT_FILE });
ResourceVersionType.WORD_HITS_FILE = "word-hits.bin";
ResourceVersionType.WORD_HITS = new ResourceVersionType({ filename: ResourceVersionType.WORD_HITS_FILE });
ResourceVersionType.LINK_HITS_FILE = "link-hits.bin";
ResourceVersionType.LINK_HITS = new ResourceVersionType({ filename: ResourceVersionType.LINK_HITS_FILE });
ResourceVersionType.RAW_HEADERS_FILE = "headers.txt";
ResourceVersionType.RAW_HEADERS = new ResourceVersionType({ filename: ResourceVersionType.RAW_HEADERS_FILE });
ResourceVersionType.TITLE_FILE = "title.txt";
ResourceVersionType.TITLE = new ResourceVersionType({ filename: ResourceVersionType.TITLE_FILE });
ResourceVersionType.WIKI_TREE_FILE = "wiki-tree.txt";
ResourceVersionType.WIKI_TREE = new ResourceVersionType({ filename: ResourceVersionType.WIKI_TREE_FILE });
ResourceVersionType.BAG_OF_WORDS_FILE = "bow.bin";
ResourceVersionType.BAG_OF_WORDS = new ResourceVersionType({ filename: ResourceVersionType.BAG_OF_WORDS_FILE });
ResourceVersionType.BINARY_BAG_OF_WORDS_FILE = "bin-bow.bin";
ResourceVersionType.BINARY_BAG_OF_WORDS = new ResourceVersionType({ filename: ResourceVersionType.BINARY_BAG_OF_WORDS_FILE });


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SQL_PARAMS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DB_CLIENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SQL; });
/* harmony import */ var common_DNS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var mysql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var mysql__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mysql__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var common_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);







const SQL_PARAMS = {
    user: "newsreduce",
    database: "newsreduce",
    supportBigNumbers: true,
};
let DB_CLIENT = null;
let SQL_PASSWORD = null;
class SQL {
    static async db() {
        if (DB_CLIENT === null) {
            let ip = await common_DNS__WEBPACK_IMPORTED_MODULE_0__[/* DNS */ "a"].lookup(common_config__WEBPACK_IMPORTED_MODULE_2__[/* MAIN_HOSTNAME */ "c"]);
            const myIP = await common_DNS__WEBPACK_IMPORTED_MODULE_0__[/* DNS */ "a"].whoami();
            if (ip === myIP)
                ip = common_config__WEBPACK_IMPORTED_MODULE_2__[/* LOCALHOST */ "b"];
            Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("Fetching SQL config.");
            const params = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(common_config__WEBPACK_IMPORTED_MODULE_2__[/* NET_AGENT_ENDPOINT */ "d"]).then(res => res.json()).catch(_ => null);
            if (params)
                SQL_PASSWORD = params.sql;
            Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("Fetched SQL config.");
            const sqlParams = { ...SQL_PARAMS, password: SQL_PASSWORD, host: ip };
            let newClient = Object(mysql__WEBPACK_IMPORTED_MODULE_1__["createConnection"])(sqlParams);
            newClient.on("error", async (error) => {
                const oldDB = DB_CLIENT;
                DB_CLIENT = null;
                oldDB.destroy();
                await SQL.db();
                if (error) {
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(`${error.errno}`);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.code);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.message);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.name);
                    Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(error.sqlMessage);
                    Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "e"])(JSON.stringify(error));
                }
            });
            // Be careful for concurrency bugs creating multiple connections.
            if (DB_CLIENT === null)
                DB_CLIENT = newClient;
            else
                newClient.destroy();
        }
        return DB_CLIENT;
    }
    static async tryLoop(cb) {
        for (let attempt = 0; attempt < 10; ++attempt) {
            try {
                const response = await new Promise(cb);
                return response;
            }
            catch (err) {
                Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])("error on attempt", attempt.toString());
                Object(common_logging__WEBPACK_IMPORTED_MODULE_3__[/* log */ "a"])(err);
                Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "e"])("error on attempt " + attempt.toString());
                Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* fancyLog */ "e"])(JSON.stringify(err));
                const oldClient = DB_CLIENT;
                DB_CLIENT = null;
                oldClient.destroy();
                await SQL.db();
            }
        }
        return [];
    }
    static async query(template, params = []) {
        return this.tryLoop((res, rej) => {
            SQL.db().then(db => {
                db.query(template, params, (err, results) => {
                    if (err)
                        rej(err);
                    else
                        res(results);
                });
            });
        });
    }
    static async destroy() {
        (await SQL.db()).destroy();
    }
    static csvField(param) {
        //fancyLog("csvField " + `${param}`);
        let stringified;
        if (param === null || param === undefined)
            stringified = "NULL";
        else if (typeof param === "boolean") {
            const paramAsTinyint = param ? 1 : 0;
            stringified = `"${paramAsTinyint}"`;
        }
        else {
            const paramAsString = param.toString();
            const escapedParam = paramAsString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            stringified = `"${escapedParam}"`;
        }
        return stringified;
    }
    static csvRow(params) {
        return params.map(SQL.csvField).join(",");
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return EVENT_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return FETCHER_BIRTH_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return FETCHER_DEATH_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return HTML_PROCESS_BIRTH_LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return HTML_PROCESS_DEATH_LOG; });
/* unused harmony export NET_AGENT_LOG */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return SCHEDULE_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return COLD_START_COMPLETE; });
/* unused harmony export WIKI_PROCESS_COMPLETE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return FETCH_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return HTML_PROCESS_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return COMPRESS_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DELETE_FILES; });
/* unused harmony export UNLOCK_FILE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return COMPRESSOR_LOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return SYNC_LOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BULK_INSERT_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FAILURE_CACHE; });
const EVENT_LOG = "event-log";
const FETCHER_BIRTH_LOG = "fetcher-birth-log";
const FETCHER_DEATH_LOG = "fetcher-death-log";
const HTML_PROCESS_BIRTH_LOG = "html-process-birth-log";
const HTML_PROCESS_DEATH_LOG = "html-process-death-log";
const NET_AGENT_LOG = "net-agent-log";
const SCHEDULE_COMPLETE = "schedule-complete";
const COLD_START_COMPLETE = "cold-start-complete";
const WIKI_PROCESS_COMPLETE = "wiki-process-complete";
const FETCH_COMPLETE = "fetch-complete";
const HTML_PROCESS_COMPLETE = "html-process-complete";
const COMPRESS_COMPLETE = "compress-complete";
const DELETE_FILES = "delete-files";
const UNLOCK_FILE = "unlock-file";
const COMPRESSOR_LOCK = "compressor-lock";
const SYNC_LOCK = "sync-lock";
const BULK_INSERT_COMPLETE = "bulk-insert-complete";
const FAILURE_CACHE = "failures";


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DNS; });
/* harmony import */ var dns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var dns__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dns__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);


class DNS {
    static lookup(hostname) {
        return new Promise((res, rej) => {
            dns__WEBPACK_IMPORTED_MODULE_0___default.a.lookup(hostname, (err, address, family) => {
                if (err)
                    rej(err);
                else if (family === 4)
                    res(DNS.ipv4AsIpv6(address));
                else
                    res(address);
            });
        });
    }
    static ipv4AsIpv6(ipv4) {
        return `::ffff:${ipv4}`;
    }
    static async whoami() {
        const ip = await node_fetch__WEBPACK_IMPORTED_MODULE_1___default()("http://newsreduce.org:9999/ip").then(response => response.text());
        return ip;
    }
}


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTTPHeader", function() { return HTTPHeader; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_HTTPHeaderName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var types_objects_HTTPHeaderValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);



class HTTPHeader extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(name, value) {
        if (name && value)
            super({
                name: new types_objects_HTTPHeaderName__WEBPACK_IMPORTED_MODULE_1__["HTTPHeaderName"]({ value: name }),
                value: new types_objects_HTTPHeaderValue__WEBPACK_IMPORTED_MODULE_2__["HTTPHeaderValue"]({ value: value }),
            });
        else
            super();
    }
    insertCols() {
        return ["id", "name", "value"];
    }
    getInsertParams() {
        return [this.getID(), this.name.getID(), this.value.getID()];
    }
    hashSuffix() {
        return `${this.name.value}\0${this.value.value}`;
    }
    table() {
        return "HTTPHeader";
    }
    getDeps() {
        return [this.name, this.value];
    }
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Word", function() { return Word; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class Word extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "Word";
    }
}


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export entityIDs */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return randomBufferFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return write; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return lastChangedBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return lastChangedAfter; });
/* unused harmony export compareVersionSignatures */
/* unused harmony export findVersions */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return findTimes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findFormats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stream; });
/* unused harmony export findLatestVersion */
/* unused harmony export readLatestVersion */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var types_Entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var types_objects_ResourceVersionType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);








const FINISH = "finish";
const ERROR = "error";
const TAR_LS_PARAMS = "-atf";
const TAR_CAT_PARAMS_BEFORE_FILE = "-axf";
const TAR_CAT_PARAMS_AFTER_FILE = "-O";
async function entityIDs(entity) {
    const entityDir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])(), Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(entity));
    const files = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readdirSync(entityDir);
    return files
        .map(file => file.match(/^([0-9]+)\.tzst$/))
        .filter(match => match)
        .map(match => match[1])
        .map(BigInt);
}
function randomBufferFile() {
    return path__WEBPACK_IMPORTED_MODULE_1___default.a.join("/tmp", crypto__WEBPACK_IMPORTED_MODULE_2___default.a.randomBytes(30).toString("hex"));
}
/**
 * @param entityID the ID of the resource to be saved (a hash of the URL)
 * @param version  the version of the resource to be saved (milliseconds
 *                 since 1970-01-01 00:00:00)
 * @param src      the source of data to be saved, either as a string of
 *                 the raw data or an input stream
 *
 * @return number of bytes written
 */
async function write(entity, entityID, version, format, src) {
    const bufferFile = randomBufferFile();
    let bytesWritten;
    if (typeof src === "string" || src instanceof Buffer) {
        try {
            fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(bufferFile, src);
            bytesWritten = src.length;
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])("exception while writing string to file.");
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])(JSON.stringify(e));
            bytesWritten = -1;
        }
    }
    else {
        try {
            const dst = fs__WEBPACK_IMPORTED_MODULE_0___default.a.createWriteStream(bufferFile);
            bytesWritten = await new Promise(async (res, rej) => {
                src.on(ERROR, err => rej(err));
                dst.on(ERROR, err => rej(err));
                dst.on(FINISH, () => res(dst.bytesWritten));
                src.pipe(dst);
            });
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])("exception while writing stream to file.");
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])(JSON.stringify(e));
            bytesWritten = -1;
        }
    }
    if (bytesWritten >= 0) {
        const versions = await findVersions(entity, entityID);
        const found = versions.find(vAndFormat => vAndFormat[0] === version && vAndFormat[1].filename === format.filename);
        if (found) {
            bytesWritten = -1;
            if (fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(bufferFile)) {
                try {
                    fs__WEBPACK_IMPORTED_MODULE_0___default.a.unlinkSync(bufferFile);
                }
                catch (e) {
                    Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])("exception while removing file.");
                    Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])(JSON.stringify(e));
                    bytesWritten = -1;
                }
            }
        }
        else {
            const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* tmpDirPromise */ "j"])(), Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(entity), `${entityID}`);
            const tmpFile = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(dir, `${version}_${format.filename}`);
            await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* safeMkdir */ "h"])(dir);
            try {
                fs__WEBPACK_IMPORTED_MODULE_0___default.a.renameSync(bufferFile, tmpFile);
            }
            catch (e) {
                Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])("exception while renaming file.");
                Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])(JSON.stringify(e));
                bytesWritten = -1;
            }
        }
    }
    else if (fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(bufferFile)) {
        try {
            fs__WEBPACK_IMPORTED_MODULE_0___default.a.unlinkSync(bufferFile);
        }
        catch (e) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])("exception while removing file.");
            Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* fancyLog */ "e"])(JSON.stringify(e));
            bytesWritten = -1;
        }
    }
    return bytesWritten;
}
/*
 * Returns true if the path has been modified before 'ms'
 * milliseconds ago (exclusive).
 */
function lastChangedBefore(path, ms) {
    const stat = fs__WEBPACK_IMPORTED_MODULE_0___default.a.statSync(path);
    return stat.ctimeMs + ms < Date.now();
}
/*
 * Returns true if the path has been modified after 'ms'
 * milliseconds ago (inclusive).
 */
function lastChangedAfter(path, ms) {
    return !lastChangedBefore(path, ms);
}
const compareVersionSignatures = (v1, v2) => {
    const vID1 = v1[0];
    const vID2 = v2[0];
    const cmp = vID1 - vID2;
    if (cmp !== 0)
        return cmp;
    const vType1 = v1[1];
    const vType2 = v2[1];
    if (vType1.filename < vType2.filename)
        return -1;
    if (vType1.filename > vType2.filename)
        return +1;
    return 0;
};
async function findVersions(entity, entityID) {
    const blobDir = await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])();
    const compressedArc = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(blobDir, Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(entity), `${entityID}.tzst`);
    // Ignore files that have not been written yet.
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(compressedArc))
        return [];
    return (await Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* spawnPromise */ "h"])(() => Object(child_process__WEBPACK_IMPORTED_MODULE_3__["spawn"])(common_config__WEBPACK_IMPORTED_MODULE_4__[/* TAR */ "e"], [TAR_LS_PARAMS, compressedArc])))
        .toString()
        .split("\n") // Separate out lines.
        .map(line => line.replace(/^[0-9]+\//, "")) // Remove redundant entity ID.
        .filter(line => line.match(/^[0-9]+_/)) // Ensure this addresses a file.
        .map(line => line.split(/[/_]/, 2)) // Split on spaces and underscore.
        .map(arr => [
        parseInt(arr[0]),
        new types_objects_ResourceVersionType__WEBPACK_IMPORTED_MODULE_7__["ResourceVersionType"](arr[1])
    ])
        .sort(compareVersionSignatures);
}
async function findTimes(entity, entityID) {
    return [...new Set((await findVersions(entity, entityID)).map(([time,]) => time))].sort((a, b) => a - b);
}
async function findFormats(entity, entityID, time) {
    return (await findVersions(entity, entityID))
        .filter(([ms,]) => ms === time)
        .map(([, format]) => format);
}
async function read(entity, entityID, time, format) {
    const blobDir = await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])();
    const compressedArc = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(blobDir, Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(entity), `${entityID}.tzst`);
    const tarPath = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(`${entityID}`, `${time}_${format.filename}`);
    // Ignore files that are not written yet.
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(compressedArc))
        return null;
    const params = [TAR_CAT_PARAMS_BEFORE_FILE, compressedArc, TAR_CAT_PARAMS_AFTER_FILE, tarPath];
    return await Object(common_util__WEBPACK_IMPORTED_MODULE_6__[/* spawnPromise */ "h"])(() => Object(child_process__WEBPACK_IMPORTED_MODULE_3__["spawn"])(common_config__WEBPACK_IMPORTED_MODULE_4__[/* TAR */ "e"], params));
}
async function stream(entity, entityID, time, format) {
    const blobDir = await Object(common_config__WEBPACK_IMPORTED_MODULE_4__[/* blobDirPromise */ "f"])();
    const compressedArc = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(blobDir, Object(types_Entity__WEBPACK_IMPORTED_MODULE_5__[/* entityName */ "b"])(entity), `${entityID}.tzst`);
    const tarPath = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(`${entityID}`, `${time}_${format.filename}`);
    // Ignore files that are not written yet.
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(compressedArc))
        return null;
    const params = [TAR_CAT_PARAMS_BEFORE_FILE, compressedArc, TAR_CAT_PARAMS_AFTER_FILE, tarPath];
    return Object(child_process__WEBPACK_IMPORTED_MODULE_3__["spawn"])(common_config__WEBPACK_IMPORTED_MODULE_4__[/* TAR */ "e"], params).stdout;
}
async function findLatestVersion(entity, entityID, format) {
    const versions = await findVersions(entity, entityID);
    const sorted = versions
        .filter(version => version[1].filename === format.filename)
        .sort((a, b) => {
        const cmp = a[0] - b[0];
        if (cmp !== 0)
            return cmp;
        if (a[1].filename < b[1].filename)
            return -1;
        if (a[1].filename > b[1].filename)
            return +1;
        return 0;
    });
    if (!sorted || !sorted.length)
        return -1;
    else {
        const [time,] = sorted[sorted.length - 1];
        return time;
    }
}
async function readLatestVersion(entity, entityID, format) {
    const latestVersion = await findLatestVersion(entity, entityID, format);
    if (latestVersion === -1)
        return null;
    return await read(entity, entityID, latestVersion, format);
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Host", function() { return Host; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var common_Redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);



class Host extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(paramsOrName, throttle) {
        if (paramsOrName === null || paramsOrName === undefined)
            super();
        else if (typeof paramsOrName === "string") {
            super({
                name: paramsOrName,
                throttle,
            });
        }
        else
            super(paramsOrName);
    }
    hashSuffix() {
        return this.name;
    }
    insertCols() {
        return ["id", "name", "throttle"];
    }
    getInsertParams() {
        return [this.getID(), this.name, this.throttle ? this.throttle : 1050];
    }
    table() {
        return "Host";
    }
    async applyThrottle() {
        await common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* REDIS_PARAMS */ "a"].throttle).setpx(this.name, this.throttle, common_util__WEBPACK_IMPORTED_MODULE_2__[/* STR_ONE */ "b"]);
    }
    async crawlAllowed() {
        return !(await common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* REDIS_PARAMS */ "a"].throttle).eq(this.name));
    }
    async popURLForFetching() {
        return await common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* Redis */ "b"].renewRedis(common_Redis__WEBPACK_IMPORTED_MODULE_1__[/* REDIS_PARAMS */ "a"].fetchSchedule).zpopmax(this.name, 1);
    }
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceURLPath", function() { return ResourceURLPath; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class ResourceURLPath extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "ResourceURLPath";
    }
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceURLQuery", function() { return ResourceURLQuery; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class ResourceURLQuery extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "ResourceURLQuery";
    }
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceVersion", function() { return ResourceVersion; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class ResourceVersion extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    insertCols() {
        return ["resource", "time", "type", "length"];
    }
    getInsertParams() {
        return [this.resource.getID(), this.time, this.type.getID(), this.length];
    }
    table() {
        return "ResourceVersion";
    }
    getDeps() {
        return [this.resource, this.type];
    }
}


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientHeader", function() { return ClientHeader; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_Client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var types_objects_HTTPHeader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);



class ClientHeader extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(clientName, headerName, value) {
        if (clientName && headerName && value)
            super({
                client: new types_objects_Client__WEBPACK_IMPORTED_MODULE_1__["Client"]({ name: clientName }),
                header: new types_objects_HTTPHeader__WEBPACK_IMPORTED_MODULE_2__["HTTPHeader"](headerName.toLowerCase(), value),
            });
    }
    insertCols() {
        return ["client", "header"];
    }
    getInsertParams() {
        return [this.client.getID(), this.header.getID()];
    }
    table() {
        return "ClientHeader";
    }
    getDeps() {
        return [this.client, this.header];
    }
}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Client", function() { return Client; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class Client extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    hashSuffix() {
        return this.name;
    }
    insertCols() {
        return ["id", "name", "httpVersion"];
    }
    getInsertParams() {
        return [this.getID(), this.name, this.httpVersion];
    }
    table() {
        return "Client";
    }
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Anchor", function() { return Anchor; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class Anchor extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "Anchor";
    }
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceHash", function() { return ResourceHash; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class ResourceHash extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "ResourceHash";
    }
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceLink", function() { return ResourceLink; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var types_objects_Anchor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);



class ResourceLink extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(parentOrObj, child, value) {
        if (parentOrObj === null || parentOrObj === undefined)
            super();
        else if (typeof parentOrObj === "string")
            super({
                parent: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](parentOrObj),
                child: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](child),
                value: new types_objects_Anchor__WEBPACK_IMPORTED_MODULE_2__["Anchor"](value),
            });
        else
            super(parentOrObj);
    }
    insertCols() {
        return ["parent", "child", "value"];
    }
    getInsertParams() {
        return [this.parent.getID(), this.child.getID(), this.value.getID()];
    }
    table() {
        return "ResourceLink";
    }
    getDeps() {
        return [this.parent, this.child, this.value];
    }
    toString() {
        return `${this.parent.toURL()}-->${this.child.toURL()}`;
    }
}


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Title", function() { return Title; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class Title extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "Title";
    }
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTTPHeaderName", function() { return HTTPHeaderName; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class HTTPHeaderName extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "HTTPHeaderName";
    }
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTTPHeaderValue", function() { return HTTPHeaderValue; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class HTTPHeaderValue extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "HTTPHeaderValue";
    }
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class Vector extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "Vector";
    }
}


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("redis");

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceThrottle", function() { return ResourceThrottle; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);


class ResourceThrottle extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(url, throttle) {
        if (url)
            super({
                resource: new _ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](url),
                throttle,
            });
        else
            super();
    }
    insertCols() {
        return ["resource", "throttle"];
    }
    getInsertParams() {
        return [this.resource.getID(), this.throttle];
    }
    table() {
        return "ResourceThrottle";
    }
    idCol() {
        return "resource";
    }
    getDeps() {
        return [this.resource];
    }
}


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WordVectorSource", function() { return WordVectorSource; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class WordVectorSource extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    getInsertParams() {
        return [this.resource.getID(), this.label];
    }
    table() {
        return "WordVectorSource";
    }
    insertCols() {
        return ["resource", "label"];
    }
    idCol() {
        return "resource";
    }
    getDeps() {
        return [this.resource];
    }
}


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WikiCategory", function() { return WikiCategory; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class WikiCategory extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    insertCols() {
        return ["parent", "child"];
    }
    getInsertParams() {
        return [this.parent.getID(), this.child.getID()];
    }
    table() {
        return "WikiCategory";
    }
    getDeps() {
        return [this.parent, this.child];
    }
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceLinkHash", function() { return ResourceLinkHash; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceLink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var types_objects_ResourceHash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);



class ResourceLinkHash extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(parentOrObj, child, hash) {
        if (!parentOrObj)
            super();
        else if (typeof parentOrObj === "string")
            super({
                link: new types_objects_ResourceLink__WEBPACK_IMPORTED_MODULE_1__["ResourceLink"](parentOrObj, child),
                hash: new types_objects_ResourceHash__WEBPACK_IMPORTED_MODULE_2__["ResourceHash"](hash),
            });
        else
            super(parentOrObj);
    }
    insertCols() {
        return ["parent", "child", "hash"];
    }
    getInsertParams() {
        return [this.link.parent.getID(), this.link.child.getID(), this.hash.getID()];
    }
    table() {
        return "ResourceLinkHash";
    }
    getDeps() {
        return [this.link, this.hash];
    }
    toString() {
        return `${this.link.toString()}#${this.hash.value}`;
    }
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NewsSourceWiki", function() { return NewsSourceWiki; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);


class NewsSourceWiki extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(url) {
        super({
            resource: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](url),
        });
    }
    insertCols() {
        return ["resource"];
    }
    getInsertParams() {
        return [this.resource.getID()];
    }
    table() {
        return "NewsSourceWiki";
    }
    idCol() {
        return "resource";
    }
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceHeader", function() { return ResourceHeader; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var types_objects_HTTPHeader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);



class ResourceHeader extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(url, name, value) {
        if (url)
            super({
                resource: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](url),
                header: new types_objects_HTTPHeader__WEBPACK_IMPORTED_MODULE_2__["HTTPHeader"](name, value),
            });
        else
            super();
    }
    insertCols() {
        return ["resource", "header"];
    }
    getInsertParams() {
        return [this.resource.getID(), this.header.getID()];
    }
    table() {
        return "ResourceHeader";
    }
    getDeps() {
        return [this.resource, this.header];
    }
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceTitle", function() { return ResourceTitle; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _Title__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);



class ResourceTitle extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(urlOrObject, title) {
        if (urlOrObject === null || urlOrObject === undefined)
            super();
        else if (typeof urlOrObject === "string")
            super({
                resource: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](urlOrObject),
                title: new _Title__WEBPACK_IMPORTED_MODULE_2__["Title"](title),
            });
        else
            super(urlOrObject);
    }
    insertCols() {
        return ["resource", "title"];
    }
    getInsertParams() {
        return [this.resource.getID(), this.title.getID()];
    }
    table() {
        return "ResourceTitle";
    }
    getDeps() {
        return [this.resource, this.title];
    }
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WikiPage", function() { return WikiPage; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);


class WikiPage extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    constructor(url) {
        super({
            resource: new types_objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](url),
        });
    }
    insertCols() {
        return ["resource"];
    }
    getInsertParams() {
        return [this.resource.getID()];
    }
    table() {
        return "WikiPage";
    }
    idCol() {
        return "resource";
    }
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientCookie", function() { return ClientCookie; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class ClientCookie extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    insertCols() {
        return ["client", "host", "value"];
    }
    getInsertParams() {
        return [this.client.getID(), this.host.getID(), this.value];
    }
    table() {
        return "ClientCookie";
    }
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLAttribute", function() { return HTMLAttribute; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class HTMLAttribute extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    hashSuffix() {
        return `${this.name.value}\0${this.value.value}`;
    }
    insertCols() {
        return ["id", "name", "value"];
    }
    getInsertParams() {
        return [this.getID(), this.name.getID(), this.value.getID()];
    }
    table() {
        return "HTMLAttribute";
    }
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLAttributeName", function() { return HTMLAttributeName; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class HTMLAttributeName extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "HTMLAttributeName";
    }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLAttributeValue", function() { return HTMLAttributeValue; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class HTMLAttributeValue extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "HTMLAttributeValue";
    }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLNode", function() { return HTMLNode; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class HTMLNode extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    hashSuffix() {
        const attributes = Object
            .keys(this.attributes)
            .sort()
            .map(key => `${key}\0${this.attributes[key]}`)
            .join("\0");
        return `${this.tag}\0${attributes}`;
    }
    insertCols() {
        return ["id", "tag"];
    }
    getInsertParams() {
        return [this.getID(), this.tag];
    }
    table() {
        return "HTMLNode";
    }
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLNodeAttribute", function() { return HTMLNodeAttribute; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class HTMLNodeAttribute extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    insertCols() {
        return ["id", "node", "attribute"];
    }
    getInsertParams() {
        return [this.node.getID(), this.attribute.getID()];
    }
    table() {
        return "HTMLNodeAttribute";
    }
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLTag", function() { return HTMLTag; });
/* harmony import */ var _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

class HTMLTag extends _SimpleHashObject__WEBPACK_IMPORTED_MODULE_0__["SimpleHashObject"] {
    table() {
        return "HTMLTag";
    }
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceHTMLHead", function() { return ResourceHTMLHead; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

class ResourceHTMLHead extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    insertCols() {
        return ["resource", "node"];
    }
    getInsertParams() {
        return [this.resource.getID(), this.node.getID()];
    }
    table() {
        return "ResourceHTMLHead";
    }
}


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BYTES_PER_FLOAT", function() { return BYTES_PER_FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WordVector", function() { return WordVector; });
/* harmony import */ var types_DBObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Word__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _WordVectorSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);




const BYTES_PER_FLOAT = 2;
const UNIQUE_VALUES = 1 << (BYTES_PER_FLOAT << 3);
const MIN_VALUE = -(UNIQUE_VALUES >> 1);
const MAX_VALUE = (UNIQUE_VALUES >> 1) - 1;
class WordVector extends types_DBObject__WEBPACK_IMPORTED_MODULE_0__[/* DBObject */ "a"] {
    getDeps() {
        return [this.word, this.source, this.vector];
    }
    getInsertParams() {
        return [this.word.getID(), this.source.resource.getID(), this.vector.getID()];
    }
    table() {
        return "WordVector";
    }
    insertCols() {
        return ["word", "source", "vector"];
    }
    static vectorToBuffer(vector, buffer = Buffer.alloc(vector.length * 2)) {
        let offset = 0;
        for (const value of vector)
            offset = WordVector.floatToBytes(value, buffer, offset).offset;
        return buffer;
    }
    static bufferToVector(buffer) {
        let offset = 0;
        const floats = new Array(buffer.length >> 1);
        while (offset < buffer.length) {
            floats[offset >> 1] = this.floatFromBytes(buffer, offset).float;
            offset += 2;
        }
        return floats;
    }
    static floatToBytes(float, buffer = Buffer.alloc(2), offset = 0) {
        let integer = Math.round(float * 10000);
        if (integer < MIN_VALUE)
            integer = MIN_VALUE;
        if (integer > MAX_VALUE)
            integer = MAX_VALUE;
        let naturalNumber = integer - MIN_VALUE;
        buffer.writeUInt16BE(naturalNumber, offset);
        offset += 2;
        return { buffer, offset };
    }
    static floatFromBytes(buffer, offset = 0) {
        const naturalNumber = buffer.readUInt16BE(offset);
        offset += 2;
        let integer = naturalNumber + MIN_VALUE;
        if (integer < MIN_VALUE)
            integer = MIN_VALUE;
        if (integer > MAX_VALUE)
            integer = MAX_VALUE;
        const float = integer / 10000;
        return { float, offset };
    }
    static fromString(input, source) {
        if (input === null)
            throw new Error(`word vector null: ${input}`);
        if (input === undefined)
            throw new Error(`word vector undefined: ${input}`);
        if (input === "")
            throw new Error(`word vector empty: ${input}`);
        const tokens = input.split(" ");
        if (tokens.length === 0)
            throw new Error(`word vector tokens length empty: ${input}`);
        let wordValue = tokens[0];
        if (wordValue === "")
            throw new Error(`word vector word empty: ${input}`);
        const word = new _Word__WEBPACK_IMPORTED_MODULE_1__["Word"](wordValue.toLowerCase());
        const vector = new _Vector__WEBPACK_IMPORTED_MODULE_3__["Vector"](this.vectorToBuffer(tokens.slice(1).map(s => parseFloat(s))));
        return new WordVector({ vector, word, source: new _WordVectorSource__WEBPACK_IMPORTED_MODULE_2__["WordVectorSource"]({ resource: source }) });
    }
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("mysql");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./Anchor": 26,
	"./Anchor.js": 26,
	"./Client": 25,
	"./Client.js": 25,
	"./ClientCookie": 43,
	"./ClientCookie.js": 43,
	"./ClientHeader": 23,
	"./ClientHeader.js": 23,
	"./HTMLAttribute": 44,
	"./HTMLAttribute.js": 44,
	"./HTMLAttributeName": 45,
	"./HTMLAttributeName.js": 45,
	"./HTMLAttributeValue": 46,
	"./HTMLAttributeValue.js": 46,
	"./HTMLNode": 47,
	"./HTMLNode.js": 47,
	"./HTMLNodeAttribute": 48,
	"./HTMLNodeAttribute.js": 48,
	"./HTMLTag": 49,
	"./HTMLTag.js": 49,
	"./HTTPHeader": 16,
	"./HTTPHeader.js": 16,
	"./HTTPHeaderName": 30,
	"./HTTPHeaderName.js": 30,
	"./HTTPHeaderValue": 31,
	"./HTTPHeaderValue.js": 31,
	"./Host": 19,
	"./Host.js": 19,
	"./NewsSourceWiki": 39,
	"./NewsSourceWiki.js": 39,
	"./ResourceHTMLHead": 50,
	"./ResourceHTMLHead.js": 50,
	"./ResourceHash": 27,
	"./ResourceHash.js": 27,
	"./ResourceHeader": 40,
	"./ResourceHeader.js": 40,
	"./ResourceLink": 28,
	"./ResourceLink.js": 28,
	"./ResourceLinkHash": 38,
	"./ResourceLinkHash.js": 38,
	"./ResourceThrottle": 35,
	"./ResourceThrottle.js": 35,
	"./ResourceTitle": 41,
	"./ResourceTitle.js": 41,
	"./ResourceURL": 7,
	"./ResourceURL.js": 7,
	"./ResourceURLPath": 20,
	"./ResourceURLPath.js": 20,
	"./ResourceURLQuery": 21,
	"./ResourceURLQuery.js": 21,
	"./ResourceVersion": 22,
	"./ResourceVersion.js": 22,
	"./ResourceVersionType": 10,
	"./ResourceVersionType.js": 10,
	"./SimpleHashObject": 4,
	"./SimpleHashObject.js": 4,
	"./Title": 29,
	"./Title.js": 29,
	"./Vector": 32,
	"./Vector.js": 32,
	"./WikiCategory": 37,
	"./WikiCategory.js": 37,
	"./WikiPage": 42,
	"./WikiPage.js": 42,
	"./Word": 17,
	"./Word.js": 17,
	"./WordVector": 51,
	"./WordVector.js": 51,
	"./WordVectorSource": 36,
	"./WordVectorSource.js": 36
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 53;

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SAFELY_EXIT */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return startProcessor; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var common_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _Redis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
/* harmony import */ var common_SQL__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);







function dangerouslyExit() {
    Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* fancyLog */ "e"])("Safety procedure activated. Exiting.");
    for (const connection of Object.values(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* STATIC_CONNECTIONS */ "c"]))
        if (connection && connection.connected)
            connection.quit();
    for (const connection of _Redis__WEBPACK_IMPORTED_MODULE_5__[/* SUB_CONNECTIONS */ "d"])
        if (connection && connection.connected)
            connection.quit();
    if (common_SQL__WEBPACK_IMPORTED_MODULE_6__[/* DB_CLIENT */ "a"])
        common_SQL__WEBPACK_IMPORTED_MODULE_6__[/* DB_CLIENT */ "a"].destroy();
    if (INTERVAL)
        clearInterval(INTERVAL);
    if (SAFETY_INTERVAL)
        clearInterval(SAFETY_INTERVAL);
}
let LOCKS = {};
async function synchronised(name, f, postcondition) {
    if (name in LOCKS)
        return;
    if (SAFELY_EXIT[0])
        dangerouslyExit();
    LOCKS[name] = true;
    f().then(() => {
        delete LOCKS[name];
        _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].renewRedis(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events).publish(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"], postcondition);
        if (SAFELY_EXIT[0])
            dangerouslyExit();
    });
}
let INTERVAL = undefined;
let SAFETY_INTERVAL = undefined;
let SAFELY_EXIT = [false];
function startProcessor(f, preconditions, postcondition, options = { interval: true, period: 2000 }) {
    const name = crypto__WEBPACK_IMPORTED_MODULE_1___default.a.randomBytes(30).toString("base64");
    if (options.interval || options.interval === undefined)
        INTERVAL = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "g"])(() => synchronised(name, f, postcondition), options.period ? options.period : 2000);
    let events;
    if (preconditions && preconditions.size > 0) {
        events = _Redis__WEBPACK_IMPORTED_MODULE_5__[/* Redis */ "b"].newSub(_Redis__WEBPACK_IMPORTED_MODULE_5__[/* REDIS_PARAMS */ "a"].events);
        events.client.subscribe(common_events__WEBPACK_IMPORTED_MODULE_2__[/* EVENT_LOG */ "f"]);
        events.client.on("message", (_, msg) => {
            if (preconditions.has(msg))
                synchronised(name, f, postcondition);
        });
    }
    else
        events = null;
    SAFETY_INTERVAL = Object(common_util__WEBPACK_IMPORTED_MODULE_4__[/* setImmediateInterval */ "g"])(async () => {
        const content = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(await Object(common_config__WEBPACK_IMPORTED_MODULE_3__[/* safetyFilePromise */ "i"])()).toString();
        if (content.match(/1/))
            SAFELY_EXIT[0] = true;
    }, 1000);
    return { interval: INTERVAL, events };
}


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BinaryBag; });
/* harmony import */ var common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _objects_Word__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);


class BinaryBag {
    constructor(builder, bag = new Set()) {
        this.bag = bag;
        this.builder = builder;
        this.objects = new Map();
    }
    register(value) {
        const obj = this.builder(value);
        const wordID = obj.getID();
        this.bag.add(wordID);
    }
    toBuffer() {
        const ids = [...this.bag.keys()];
        const fileData = Buffer.alloc(this.bag.size * 12);
        let offset = 0;
        for (const id of ids.sort(common_util__WEBPACK_IMPORTED_MODULE_0__[/* CMP_BIG_INT */ "a"])) {
            Object(common_util__WEBPACK_IMPORTED_MODULE_0__[/* writeBigUInt96BE */ "k"])(id, fileData, offset);
            offset += 12;
        }
        return fileData;
    }
    fromBuffer(buffer) {
        const bag = new Set();
        const bufferLength = buffer.length;
        let offset = 0;
        while (offset < bufferLength) {
            const id = Object(common_util__WEBPACK_IMPORTED_MODULE_0__[/* bytesToBigInt */ "c"])(buffer.slice(offset, offset + 12));
            offset += 12;
            bag.add(id);
        }
        return new BinaryBag(this.builder, bag);
    }
    toString() {
        const ids = Object(common_util__WEBPACK_IMPORTED_MODULE_0__[/* iteratorToArray */ "f"])(this.bag.keys()).sort(common_util__WEBPACK_IMPORTED_MODULE_0__[/* CMP_BIG_INT */ "a"]);
        let str = "";
        for (const id of ids)
            str += `${id}`.padStart(29, "0") + "\n";
        return str;
    }
    static ofWords() {
        return new BinaryBag(value => new _objects_Word__WEBPACK_IMPORTED_MODULE_1__["Word"](value));
    }
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ selectPreSchedule; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ schedule; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ selectResourceVersions; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ selectBagOfWordsByHost; });

// CONCATENATED MODULE: ./dist/main/sql.js
/* harmony default export */ var sql = ({
    // /home/sean/newsreduce/sql/BULK_INSERT.sql
    BULK_INSERT: "LOAD DATA INFILE ? IGNORE INTO TABLE ? FIELDS TERMINATED BY ',' ENCLOSED BY ''' ESCAPED BY '\\' LINES TERMINATED BY '\n' ?",
    // /home/sean/newsreduce/sql/DELETE_RESOURCE_HEADERS.sql
    DELETE_RESOURCE_HEADERS: "delete from ResourceHeader where resource = ? and header not in ?",
    // /home/sean/newsreduce/sql/DELETE_SCHEDULE.sql
    DELETE_SCHEDULE: "delete from Schedule where resource = ?",
    // /home/sean/newsreduce/sql/DELETE_WIKI_CATEGORIES_FOR_PARENTS.sql
    DELETE_WIKI_CATEGORIES_FOR_PARENTS: "delete from WikiCategory where parent = ? and child not in ?",
    // /home/sean/newsreduce/sql/SELECT_BAG_OF_WORDS_RESOURCE_HOST_PAIRS.sql
    SELECT_BAG_OF_WORDS_RESOURCE_HOST_PAIRS: "select u.id resource, max(v.time) time, u.host from Host h inner join ResourceURL u on u.host = h.id inner join ResourceVersion v on v.resource = u.id inner join ResourceVersionType t on t.id = v.type where t.filename = 'bow.bin' group by v.resource, v.type;",
    // /home/sean/newsreduce/sql/SELECT_HEADERS_FOR_RESOURCE.sql
    SELECT_HEADERS_FOR_RESOURCE: "select header from ResourceHeader r where r.resource = ?",
    // /home/sean/newsreduce/sql/SELECT_PRIORITY_RESOURCE_PER_HOST.sql
    SELECT_PRIORITY_RESOURCE_PER_HOST: "select min(priority) as priority, r.*, h.throttle, h.name as hostname from Schedule s inner join ResourceURL r on r.id = s.resource inner join Host h on h.id = r.host group by r.host;",
    // /home/sean/newsreduce/sql/SELECT_RESOURCES_TO_FETCH.sql
    SELECT_RESOURCES_TO_FETCH: "select id, url from ( select ResourceURL.id, URLView.url, IFNULL(max(ResourceVersion.time), 0) + ResourceThrottle.throttle as fetchAfter from ResourceURL inner join ResourceThrottle on ResourceThrottle.resource = ResourceURL.id inner join URLView on URLView.resource = ResourceURL.id left outer join ResourceVersion on ResourceVersion.resource = ResourceURL.id group by ResourceURL.id ) LastFetched where fetchAfter < round(UNIX_TIMESTAMP(CURTIME(4)) * 1000);",
    // /home/sean/newsreduce/sql/SELECT_RESOURCE_VERSIONS.sql
    SELECT_RESOURCE_VERSIONS: "select u.url, time, filename from ( select t.filename, resource, time from ResourceVersion v inner join ResourceVersionType t on t.id = v.type ) ResourcesVersionCounts inner join URLView u on u.resource = ResourcesVersionCounts.resource;",
    // /home/sean/newsreduce/sql/SELECT_TABLES.sql
    SELECT_TABLES: "select TABLE_NAME as name from information_schema.TABLES where TABLE_SCHEMA = 'newsreduce'",
    // /home/sean/newsreduce/sql/SELECT_THROTTLE_FOR_HOST.sql
    SELECT_THROTTLE_FOR_HOST: "select id, throttle from Host where id in ?",
});

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceURL.js
var ResourceURL = __webpack_require__(7);

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./dist/main/common/Redis.js
var Redis = __webpack_require__(2);

// EXTERNAL MODULE: ./dist/main/common/SQL.js
var SQL = __webpack_require__(12);

// CONCATENATED MODULE: ./dist/main/data.js





async function genericSQLPromise(query, params = [], mapper) {
    let response = await SQL["b" /* SQL */].query(query, params);
    if (mapper && response)
        response = mapper(response);
    return response;
}
function selectPreSchedule() {
    return genericSQLPromise(sql.SELECT_RESOURCES_TO_FETCH);
}
async function schedule(items) {
    Object(util["e" /* fancyLog */])(`Attempting to schedule ${items.length} URLs.`);
    const promises = [];
    let scheduled = 0;
    for (const item of items) {
        const resourceURL = new ResourceURL["ResourceURL"](item.url);
        if (!await resourceURL.isFetchLocked()) {
            promises.push(Redis["b" /* Redis */].renewRedis(Redis["a" /* REDIS_PARAMS */].fetchSchedule)
                .zincrby(resourceURL.host.name, 1, item.url));
            ++scheduled;
        }
    }
    if (scheduled)
        Object(util["e" /* fancyLog */])(`Scheduled ${scheduled} URLs.`);
    await Promise.all(promises);
}
async function selectResourceVersions() {
    const query = sql.SELECT_RESOURCE_VERSIONS;
    const rows = await genericSQLPromise(query);
    const resources = {};
    for (const row of rows) {
        const url = row.url;
        const time = row.time;
        const filename = row.filename;
        let times;
        if (url in resources)
            times = resources[url];
        else {
            times = new Map();
            resources[url] = times;
        }
        let formats;
        if (times.has(time)) {
            formats = times.get(time);
        }
        else {
            formats = new Set();
            times.set(time, formats);
        }
        formats.add(filename);
    }
    return resources;
}
async function selectBagOfWordsByHost() {
    const query = sql.SELECT_BAG_OF_WORDS_RESOURCE_HOST_PAIRS;
    const rows = await genericSQLPromise(query);
    const hosts = new Map();
    for (const row of rows) {
        const resource = row.resource;
        const time = row.time;
        const host = row.host;
        const version = [resource, time];
        if (hosts.has(host))
            hosts.get(host).push(version);
        else
            hosts.set(host, [version]);
    }
    return hosts;
}


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Hits_Hits; });

// CONCATENATED MODULE: ./dist/main/types/Hit.js
class Hit {
    constructor(prominentHTMLTag, relativePositionInDocument) {
        this.prominentHTMLTag = prominentHTMLTag;
        this.relativePositionInDocument = relativePositionInDocument;
    }
    toByte() {
        return ((this.prominentHTMLTag << 4) | this.relativePositionInDocument);
    }
    static fromByte(byte) {
        const prominentHTMLTag = byte >> 4;
        const relativePositionInDocument = byte & 0b1111;
        return new Hit(prominentHTMLTag, relativePositionInDocument);
    }
}

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(0);

// CONCATENATED MODULE: ./dist/main/types/Hits.js


const POSITION_BITS = 4;
class Hits_Hits {
    constructor(builder, lengthBytes, hits = new Map()) {
        this.hits = hits;
        this.builder = builder;
        this.lengthBytes = lengthBytes;
        this.objects = new Map();
    }
    register(value, n, of, type) {
        let obj;
        try {
            obj = this.builder(value);
        }
        catch (e) {
            Object(util["e" /* fancyLog */])("caught exception while gathering hits");
            Object(util["e" /* fancyLog */])(JSON.stringify(e));
            return n;
        }
        const id = obj.getID();
        let hits;
        if (this.hits.has(id))
            hits = this.hits.get(id);
        else {
            hits = [];
            this.hits.set(id, hits);
            this.objects.set(id, obj);
        }
        const position = Math.floor((n / of) * (1 << POSITION_BITS));
        hits.push(new Hit(type, position));
        return n + 1;
    }
    toBuffer() {
        let bytes = 0;
        // 12 bytes per ID
        bytes += this.hits.size * 12;
        // N bytes per ID (for length of hit list).
        bytes += this.hits.size * this.lengthBytes;
        const ids = [...this.hits.keys()];
        // 1 byte per hit
        bytes += [...this.hits.values()].map(hits => hits.length).reduce((a, b) => a + b, 0);
        const fileData = Buffer.alloc(bytes);
        let offset = 0;
        for (const id of ids.sort(util["a" /* CMP_BIG_INT */])) {
            Object(util["k" /* writeBigUInt96BE */])(id, fileData, offset);
            offset += 12;
            const hits = this.hits.get(id).sort().slice(0, (1 << this.lengthBytes * 8) - 1)
                .map(hit => hit.toByte());
            const length = Math.min(hits.length, (1 << this.lengthBytes * 8) - 1);
            Object(util["j" /* writeAnyNumberBE */])(length, fileData, offset, this.lengthBytes);
            offset += this.lengthBytes;
            Buffer.from(hits).copy(fileData, offset);
            offset += hits.length;
        }
        return fileData;
    }
    toString() {
        const wordIDs = Object(util["f" /* iteratorToArray */])(this.hits.keys()).sort(util["a" /* CMP_BIG_INT */]);
        let str = "";
        for (const id of wordIDs) {
            str += `${id}`.padStart(29, "0") + " ";
            const bytes = this.hits.get(id).map(hit => hit.toByte());
            str += Buffer.of(...bytes).toString("hex") + "\n";
        }
        return str;
    }
    fromBuffer(buffer) {
        const hits = new Map();
        const bufferLength = buffer.length;
        let offset = 0;
        while (offset < bufferLength) {
            const id = Object(util["c" /* bytesToBigInt */])(buffer.slice(offset, offset + 12));
            offset += 12;
            const hitsLength = Object(util["d" /* bytesToNumber */])(buffer.slice(offset, offset + this.lengthBytes));
            offset += this.lengthBytes;
            const itemHits = new Array(Number(hitsLength));
            for (let i = 0; i < hitsLength; ++i) {
                const hit = Hit.fromByte(buffer[offset + i]);
                itemHits[i] = hit;
            }
            offset += hitsLength;
            hits.set(id, itemHits);
        }
        return this.build(hits);
    }
}


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ BagOfWords_BagOfWords; });

// EXTERNAL MODULE: ./dist/main/types/BinaryBag.js
var BinaryBag = __webpack_require__(55);

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(0);

// CONCATENATED MODULE: ./dist/main/types/Bag.js


class Bag_Bag {
    constructor(builder, bag = new Map(), lengthBytes = 2) {
        this.bag = bag;
        this.builder = builder;
        this.objects = new Map();
        this.lengthBytes = lengthBytes;
    }
    register(value) {
        const obj = this.builder(value);
        const id = obj.getID();
        this.objects.set(id, obj);
        if (this.bag.has(id))
            this.bag.set(id, this.bag.get(id) + 1);
        else
            this.bag.set(id, 1);
    }
    toBinaryBag() {
        return new BinaryBag["a" /* BinaryBag */](this.builder, new Set(this.bag.keys()));
    }
    toBuffer() {
        const ids = [...this.bag.keys()];
        const fileData = Buffer.alloc(1 + this.bag.size * (12 + this.lengthBytes));
        fileData[0] = this.lengthBytes;
        let offset = 1;
        for (const id of ids.sort(util["a" /* CMP_BIG_INT */])) {
            Object(util["k" /* writeBigUInt96BE */])(id, fileData, offset);
            offset += 12;
            const count = Math.min(this.bag.get(id), (1 << this.lengthBytes * 8) - 1);
            Object(util["j" /* writeAnyNumberBE */])(count, fileData, offset, this.lengthBytes);
            offset += this.lengthBytes;
        }
        return fileData;
    }
    fromBuffer(buffer) {
        const bag = new Map();
        const bufferLength = buffer.length;
        const lengthBytes = buffer[0];
        let offset = 1;
        while (offset < bufferLength) {
            const id = Object(util["c" /* bytesToBigInt */])(buffer.slice(offset, offset + 12));
            offset += 12;
            const count = Object(util["d" /* bytesToNumber */])(buffer.slice(offset, offset + this.lengthBytes));
            offset += this.lengthBytes;
            bag.set(id, count);
        }
        return this.build(bag, lengthBytes);
    }
    toString() {
        const ids = Object(util["f" /* iteratorToArray */])(this.bag.keys()).sort(util["a" /* CMP_BIG_INT */]);
        let str = "";
        for (const id of ids)
            str += `${id}`.padStart(29, "0") + " " + this.bag.get(id).toString(16).padStart(this.lengthBytes * 2, "0") + "\n";
        return str;
    }
}

// EXTERNAL MODULE: ./dist/main/types/objects/Word.js
var Word = __webpack_require__(17);

// CONCATENATED MODULE: ./dist/main/types/BagOfWords.js


class BagOfWords_BagOfWords extends Bag_Bag {
    constructor(bag = new Map(), lengthBytes = 2) {
        super(value => new Word["Word"](value), bag, lengthBytes);
    }
    build(bag, lengthBytes) {
        return new BagOfWords_BagOfWords(bag, lengthBytes);
    }
}


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return start; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Redis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);




function start(f, birthLog, deathLog, preconditions, postcondition) {
    const workerID = Object(crypto__WEBPACK_IMPORTED_MODULE_2__["randomBytes"])(30).toString("hex");
    let lo;
    let hi;
    Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* setImmediateInterval */ "g"])(() => _Redis__WEBPACK_IMPORTED_MODULE_3__[/* Redis */ "b"].renewRedis(_Redis__WEBPACK_IMPORTED_MODULE_3__[/* REDIS_PARAMS */ "a"].local).publish(birthLog, workerID), 400);
    const listen = _Redis__WEBPACK_IMPORTED_MODULE_3__[/* Redis */ "b"].newSub(_Redis__WEBPACK_IMPORTED_MODULE_3__[/* REDIS_PARAMS */ "a"].local);
    listen.client.subscribe(workerID);
    listen.client.on("message", (_, msg) => {
        [lo, hi] = msg.split(" ", 2).map(BigInt);
    });
    Object(_processor__WEBPACK_IMPORTED_MODULE_1__[/* startProcessor */ "a"])(async () => f(() => lo, () => hi), preconditions, postcondition);
}


/***/ }),
/* 60 */,
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PromisePool; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

class PromisePool {
    constructor(threads) {
        this.promises = [];
        this.threads = threads;
    }
    async registerFn(fn) {
        this.promises.push(new Promise(fn));
        if (this.promises.length === this.threads)
            await this.flush();
    }
    async registerPromise(promise) {
        this.promises.push(promise);
        if (this.promises.length === this.threads) {
            await this.flush();
            Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* fancyLog */ "e"])("promise pool flush");
        }
    }
    async flush() {
        await Promise.all(this.promises);
        this.promises = [];
    }
}


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WordHits; });
/* harmony import */ var _Hits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _objects_Word__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);


class WordHits extends _Hits__WEBPACK_IMPORTED_MODULE_0__[/* Hits */ "a"] {
    constructor(hits = new Map()) {
        super(value => new _objects_Word__WEBPACK_IMPORTED_MODULE_1__["Word"](value), 2, hits);
    }
    build(hits) {
        return new WordHits(hits);
    }
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LinkHits; });
/* harmony import */ var _Hits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);


class LinkHits extends _Hits__WEBPACK_IMPORTED_MODULE_0__[/* Hits */ "a"] {
    constructor(hits = new Map()) {
        super(value => new _objects_ResourceURL__WEBPACK_IMPORTED_MODULE_1__["ResourceURL"](value), 2, hits);
    }
    build(hits) {
        return new LinkHits(hits);
    }
}


/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("jsdom");

/***/ }),
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GenericConstructor; });
class GenericConstructor {
    constructor(src) {
        if (src) {
            const dst = this;
            for (const property in src) {
                dst[property] = src[property];
            }
        }
    }
}


/***/ }),
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./dist/main/common/events.js
var events = __webpack_require__(13);

// EXTERNAL MODULE: ./dist/main/common/worker.js
var worker = __webpack_require__(59);

// EXTERNAL MODULE: ./dist/main/data.js + 1 modules
var data = __webpack_require__(56);

// EXTERNAL MODULE: ./dist/main/common/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceVersionType.js
var ResourceVersionType = __webpack_require__(10);

// EXTERNAL MODULE: ./dist/main/common/PromisePool.js
var PromisePool = __webpack_require__(61);

// CONCATENATED MODULE: ./dist/main/types/HitType.js
var HitType;
(function (HitType) {
    HitType[HitType["TITLE"] = 0] = "TITLE";
    HitType[HitType["H1"] = 1] = "H1";
    HitType[HitType["H2"] = 2] = "H2";
    HitType[HitType["H3"] = 3] = "H3";
    HitType[HitType["H4"] = 4] = "H4";
    HitType[HitType["H5"] = 5] = "H5";
    HitType[HitType["H6"] = 6] = "H6";
    HitType[HitType["FIGCAPTION"] = 7] = "FIGCAPTION";
    HitType[HitType["STRONG"] = 8] = "STRONG";
    HitType[HitType["A"] = 9] = "A";
    HitType[HitType["EM"] = 10] = "EM";
    HitType[HitType["BLOCKQUOTE"] = 11] = "BLOCKQUOTE";
    HitType[HitType["P"] = 12] = "P";
    HitType[HitType["META_DATA"] = 13] = "META_DATA";
    HitType[HitType["ACCESSABILITY_DATA"] = 14] = "ACCESSABILITY_DATA";
    HitType[HitType["OTHER_TEXT"] = 15] = "OTHER_TEXT";
})(HitType || (HitType = {}));
;
const META_NAMES_CONSIDERED = [
    "description",
    "author",
    "keywords",
];
function nodeToHitType(node) {
    let hitType;
    switch (node.tagName) {
        case "TITLE":
            hitType = HitType.TITLE;
            break;
        case "H1":
            hitType = HitType.H1;
            break;
        case "H2":
            hitType = HitType.H2;
            break;
        case "H3":
            hitType = HitType.H3;
            break;
        case "H4":
            hitType = HitType.H4;
            break;
        case "H5":
            hitType = HitType.H5;
            break;
        case "H6":
            hitType = HitType.H6;
            break;
        case "FIGCAPTION":
            hitType = HitType.FIGCAPTION;
            break;
        case "STRONG":
        case "B":
            hitType = HitType.STRONG;
            break;
        case "EM":
        case "I":
            hitType = HitType.EM;
            break;
        case "BLOCKQUOTE":
            hitType = HitType.BLOCKQUOTE;
            break;
        case "A":
            hitType = HitType.A;
            break;
        case "P":
            hitType = HitType.P;
            break;
        case "META":
            const name = node.getAttribute("name");
            if (name) {
                if (name in META_NAMES_CONSIDERED) {
                    hitType = HitType.META_DATA;
                }
                else {
                    hitType = HitType.OTHER_TEXT;
                }
            }
            else {
                const name = node.getAttribute("property");
                if (name in META_NAMES_CONSIDERED) {
                    hitType = HitType.META_DATA;
                }
                else {
                    hitType = HitType.OTHER_TEXT;
                }
            }
            break;
        default:
            if (node.hasAttribute("title") || node.hasAttribute("alt"))
                hitType = HitType.ACCESSABILITY_DATA;
            else
                hitType = HitType.OTHER_TEXT;
    }
    return hitType;
}

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceURL.js
var ResourceURL = __webpack_require__(7);

// EXTERNAL MODULE: external "jsdom"
var external_jsdom_ = __webpack_require__(64);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/DOMPool.js

class DOMPool_DOMPool {
    constructor() {
        this.pool = new Map();
    }
    renew(resource, time, buffer) {
        let dom;
        const id = resource.getID();
        if (this.pool.has(id) && this.pool.get(id).has(time))
            dom = this.pool.get(id).get(time);
        else
            dom = this.replace(resource, time, buffer);
        return dom;
    }
    replace(resource, time, buffer) {
        let dom;
        const id = resource.getID();
        if (!this.pool.has(id))
            this.pool.set(id, new Map());
        const times = this.pool.get(id);
        dom = new external_jsdom_["JSDOM"](buffer, { url: resource.toURL() });
        times.set(time, dom);
        return dom;
    }
}

// CONCATENATED MODULE: ./dist/main/services/resource-processor/functions.js







const ANCHOR_TAG = "a";
function htmlCollectionToArray(coll) {
    const array = new Array(coll.length);
    for (let position = 0; position < coll.length; ++position)
        array[position] = coll.item(position);
    return array;
}
function getAnchorsWithHREF(dom) {
    const truthyAndFalseyAnchors = htmlCollectionToArray(dom.window.document.getElementsByTagName(ANCHOR_TAG));
    return truthyAndFalseyAnchors.filter(a => a.href);
}
function contentFromNode(node, hitType) {
    let content;
    switch (hitType) {
        case HitType.META_DATA:
            content = node.getAttribute("content");
            break;
        case HitType.ACCESSABILITY_DATA:
            content = node.getAttribute("title");
            if (!content)
                node.getAttribute("alt");
            break;
        default:
            content = node.textContent;
    }
    return content;
}
function wordsFromNode(node, hitType) {
    const content = contentFromNode(node, hitType);
    const lc = content.toLowerCase();
    const normalised = lc.replace(/[–-]/g, "");
    const words = normalised.match(/[^ \t\s!"'^&*();:@~#\n®.,<>?/\[\]\\{}“”‘’]+/g);
    return words;
}
function filenameToBufferOrPath(resource, time, filename) {
    switch (filename) {
        case ResourceVersionType["ResourceVersionType"].RAW_ZIP_FILE:
            return new Promise(res => res(resource));
        default: return resource.read(time, new ResourceVersionType["ResourceVersionType"](filename));
    }
}
async function processResource(resource, time, formats, pool, processors) {
    const url = resource.toURL();
    console.log(`${time} ${url}`);
    const dictionary = {};
    const filenames = [...formats];
    let buffersOrPaths;
    try {
        buffersOrPaths = await Promise.all(filenames.map(filename => filenameToBufferOrPath(resource, time, filename)));
    }
    catch (e) {
        Object(util["e" /* fancyLog */])(e.toString());
    }
    const length = buffersOrPaths.length;
    for (let i = 0; i < length; ++i) {
        const bufferOrPath = buffersOrPaths[i];
        if (bufferOrPath)
            dictionary[filenames[i]] = bufferOrPath;
    }
    const localFilenames = Object.keys(dictionary);
    const domPool = new DOMPool_DOMPool();
    let reDOM = true;
    for (const processor of processors) {
        if (processor.appliesTo(localFilenames, resource)) {
            const from = processor.from();
            const inputFilenames = [...from];
            let input = {};
            const length = inputFilenames.length;
            for (let i = 0; i < length; ++i)
                input[inputFilenames[i]] = dictionary[i];
            await pool.registerPromise(processor.apply(resource, input, time, domPool, reDOM));
        }
        reDOM = !processor.ro();
    }
}
const buildProcessFunction = (processors) => async function process(lo, hi) {
    const pool = new PromisePool["a" /* PromisePool */](1);
    const resources = await Object(data["d" /* selectResourceVersions */])();
    for (const url in resources) {
        const resource = new ResourceURL["ResourceURL"](url);
        const id = resource.getID();
        if (id < lo() || id >= hi())
            continue;
        const versions = resources[url];
        for (const [time, filenames] of versions) {
            await processResource(resource, time, filenames, pool, processors);
        }
    }
    await pool.flush();
};

// EXTERNAL MODULE: ./dist/main/types/WordHits.js
var WordHits = __webpack_require__(62);

// EXTERNAL MODULE: ./dist/main/types/LinkHits.js
var LinkHits = __webpack_require__(63);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ResourceProcessor.js
const EXCLUDE = [
    "NOSCRIPT",
    "SCRIPT",
    "STYLE",
    "FORM",
    "INPUT",
    "BUTTON",
];
class ResourceProcessor {
    constructor() { }
    hosts() {
        return null;
    }
    appliesTo(formats, resource) {
        const hosts = this.hosts();
        const from = this.from();
        const to = this.to();
        return (!hosts || hosts.has(resource.host.name))
            && formats.filter(format => from.has(format)).length === from.size
            && formats.filter(format => to.has(format)).length < to.size;
    }
}

// CONCATENATED MODULE: ./dist/main/services/resource-processor/HTMLProcessor.js


const HTMLProcessor_EXCLUDE = [
    "NOSCRIPT",
    "SCRIPT",
    "STYLE",
    "FORM",
    "INPUT",
    "BUTTON",
];
class HTMLProcessor_HTMLProcessor extends ResourceProcessor {
    apply(resource, input, time, domPool, reDOM) {
        const buffer = input[ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE];
        let dom;
        if (reDOM)
            dom = domPool.replace(resource, time, buffer);
        else
            dom = domPool.renew(resource, time, buffer);
        return this.applyToDOM(dom, time);
    }
    static removeExcludedNodes(dom) {
        for (const tag of HTMLProcessor_EXCLUDE) {
            const items = dom.window.document.querySelectorAll(tag);
            for (let i = 0; i < items.length; ++i) {
                const item = items.item(i);
                item.parentElement.removeChild(item);
            }
        }
    }
}

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractHits.js








const INCLUDE_TAGS = [
    "TITLE",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "FIGCAPTION",
    "STRONG",
    "B",
    "A",
    "EM",
    "I",
    "BLOCKQUOTE",
    "P",
    "META",
];
;
function getHits(dom) {
    HTMLProcessor_HTMLProcessor.removeExcludedNodes(dom);
    const queryItems = htmlCollectionToArray(dom.window.document.querySelectorAll(INCLUDE_TAGS.join(",")));
    const blockWordData = [];
    const linksData = [];
    const truthyAnchors = getAnchorsWithHREF(dom);
    for (const anchor of truthyAnchors)
        linksData.push([anchor.href, nodeToHitType(anchor.parentElement)]);
    // Ensure no words are counted twice.
    for (const item of queryItems)
        item.parentNode.removeChild(item);
    let wordsOnPage = 0;
    for (const item of queryItems) {
        const hitType = nodeToHitType(item);
        const words = wordsFromNode(item, hitType);
        if (words && words.length) {
            blockWordData.push({ hitType, items: words });
            wordsOnPage += words.length;
        }
    }
    let n = 0;
    const wordHits = new WordHits["a" /* WordHits */]();
    for (const block of blockWordData)
        for (const word of block.items)
            wordHits.register(word, n++, wordsOnPage, block.hitType);
    for (const word of wordHits.objects.values())
        word.enqueueInsert({ recursive: true });
    n = 0;
    const linkHits = new LinkHits["a" /* LinkHits */]();
    for (const [url, hitType] of linksData)
        n = linkHits.register(url, n, linksData.length, hitType);
    for (const link of linkHits.objects.values())
        link.enqueueInsert({ recursive: true });
    return { wordHits, linkHits };
}
class ExtractHits_ExtractHits extends HTMLProcessor_HTMLProcessor {
    ro() { return false; }
    async applyToDOM(dom, time) {
        const resource = new ResourceURL["ResourceURL"](dom.window.location.toString());
        const { wordHits, linkHits } = getHits(dom);
        await Promise.all([
            resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].LINK_HITS, linkHits.toBuffer()),
            resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].WORD_HITS, wordHits.toBuffer()),
        ]);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].LINK_HITS_FILE, ResourceVersionType["ResourceVersionType"].WORD_HITS_FILE]);
    }
}

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceLink.js
var ResourceLink = __webpack_require__(28);

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceLinkHash.js
var ResourceLinkHash = __webpack_require__(38);

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceHash.js
var ResourceHash = __webpack_require__(27);

// EXTERNAL MODULE: ./dist/main/types/objects/Anchor.js
var Anchor = __webpack_require__(26);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractAHrefs.js









const HASH = "#";
function getLinks(dom) {
    const parent = new ResourceURL["ResourceURL"](dom.window.location.toString());
    const links = [];
    for (const anchor of getAnchorsWithHREF(dom)) {
        const parts = anchor.href.split(HASH, 2);
        const url = parts[0];
        const hash = parts.length > 1 ? parts[1] : "";
        const value = new Anchor["Anchor"]({ value: anchor.innerHTML });
        let child;
        try {
            child = new ResourceURL["ResourceURL"](url);
        }
        catch (e) {
            Object(util["e" /* fancyLog */])("invalid url: " + url);
            Object(util["e" /* fancyLog */])(JSON.stringify(e));
            continue;
        }
        const link = new ResourceLink["ResourceLink"]({ parent, child, value });
        if (hash)
            links.push(new ResourceLinkHash["ResourceLinkHash"]({ link, hash: new ResourceHash["ResourceHash"](hash) }));
        else
            links.push(link);
    }
    return links;
}
class ExtractAHrefs_ExtractAHrefs extends HTMLProcessor_HTMLProcessor {
    ro() { return true; }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_LINKS_TXT_FILE]);
    }
    async applyToDOM(dom, time) {
        const parent = new ResourceURL["ResourceURL"](dom.window.location.toString());
        const links = getLinks(dom);
        const urls = links.map(item => item instanceof ResourceLinkHash["ResourceLinkHash"] ? `${item.link.child.toURL()}#${item.hash.value}` : item.child.toURL());
        const fsPromise = parent.writeVersion(time, ResourceVersionType["ResourceVersionType"].RAW_LINKS_TXT, urls.join("\n"));
        const dbPromises = links.map(link => link.enqueueInsert({ recursive: true }));
        const promises = [...dbPromises, fsPromise];
        await Promise.all(promises);
    }
}

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractRawText.js



function toRawText(dom) {
    HTMLProcessor_HTMLProcessor.removeExcludedNodes(dom);
    const rawText = dom.window.document.body.textContent
        .replace(/\n\s+\n/g, "\n\n")
        .replace(/\n\n+/g, "\n\n");
    return rawText;
}
class ExtractRawText_ExtractRawText extends HTMLProcessor_HTMLProcessor {
    ro() { return true; }
    async applyToDOM(dom, time) {
        const rawText = toRawText(dom);
        const resource = new ResourceURL["ResourceURL"](dom.window.location.toString());
        await resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].RAW_WORDS_TXT, rawText);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_WORDS_TXT_FILE]);
    }
}

// EXTERNAL MODULE: ./dist/main/types/objects/WikiCategory.js
var WikiCategory = __webpack_require__(37);

// EXTERNAL MODULE: ./dist/main/types/objects/WikiPage.js
var WikiPage = __webpack_require__(42);

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceThrottle.js
var ResourceThrottle = __webpack_require__(35);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractWikiTree.js






const SUBCATEGORY_SELECTOR = "#mw-subcategories .CategoryTreeItem>a";
const CATEGORY_PAGE_SELECT = "#mw-pages .mw-category .mw-category-group li>a";
function resourceIsWikiCategory(resource) {
    return resource.ssl
        && resource.host.name === "en.wikipedia.org"
        && resource.port === 443
        && resource.path.value.match(/^\/wiki\/Category:/)
        && resource.query.value === "";
}
function getHrefs(dom, selector) {
    const node = dom.window.document.querySelectorAll(selector);
    const urls = new Array(node.length);
    for (let i = 0; i < node.length; ++i) {
        const a = node.item(i);
        if (a.href)
            urls[i] = a.href;
    }
    return urls;
}
function getSubWikiPages(wikiDoc) {
    return getHrefs(wikiDoc, CATEGORY_PAGE_SELECT);
}
function getSubWikiCategories(wikiDoc) {
    return getHrefs(wikiDoc, SUBCATEGORY_SELECTOR);
}
function getEntities(dom) {
    const parent = new ResourceURL["ResourceURL"](dom.window.location.toString());
    if (!resourceIsWikiCategory(parent))
        return [];
    const subWikiCategoryURLs = getSubWikiCategories(dom);
    const subWikiPageURLs = getSubWikiPages(dom);
    const children = subWikiPageURLs.concat(subWikiCategoryURLs);
    const relations = children
        .map(child => new ResourceURL["ResourceURL"](child))
        .map(child => new WikiCategory["WikiCategory"]({ parent, child }));
    const pages = subWikiPageURLs
        .map(url => new WikiPage["WikiPage"](url));
    const throttles = children.map(url => new ResourceThrottle["ResourceThrottle"](url, 7 * 24 * 60 * 60 * 1000));
    return relations.concat(pages).concat(throttles);
}
class ExtractWikiTree_ExtractWikiTree extends HTMLProcessor_HTMLProcessor {
    ro() { return true; }
    async applyToDOM(dom) {
        const entities = getEntities(dom);
        const promises = entities.map(entity => entity.enqueueInsert({ recursive: true }));
        await Promise.all(promises);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].WIKI_TREE_FILE]);
    }
}

// EXTERNAL MODULE: ./dist/main/types/objects/ResourceTitle.js
var ResourceTitle = __webpack_require__(41);

// EXTERNAL MODULE: ./dist/main/types/objects/Title.js
var Title = __webpack_require__(29);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractTitle.js





class ExtractTitle_ExtractTitle extends HTMLProcessor_HTMLProcessor {
    ro() { return true; }
    async applyToDOM(dom, time) {
        const resource = new ResourceURL["ResourceURL"](dom.window.location.toString());
        const titleContent = dom.window.document.title;
        const title = new Title["Title"](titleContent);
        const resourceTitle = new ResourceTitle["ResourceTitle"]({ resource, title });
        const fsPromise = resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].TITLE, titleContent);
        const dbPromise = resourceTitle.enqueueInsert({ recursive: true });
        const promises = [dbPromise, fsPromise];
        await Promise.all(promises);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].TITLE_FILE]);
    }
}

// EXTERNAL MODULE: ./dist/main/types/BagOfWords.js + 1 modules
var BagOfWords = __webpack_require__(58);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractRepresentations.js






const ExtractRepresentations_INCLUDE_TAGS = [
    "TITLE",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "FIGCAPTION",
    "BLOCKQUOTE",
    "P",
];
function getBagOfWords(dom) {
    HTMLProcessor_HTMLProcessor.removeExcludedNodes(dom);
    const queryItems = htmlCollectionToArray(dom.window.document.querySelectorAll(ExtractRepresentations_INCLUDE_TAGS.join(",")));
    // Ensure no words are counted twice.
    for (const item of queryItems)
        item.parentNode.removeChild(item);
    const bag = new BagOfWords["a" /* BagOfWords */]();
    for (const item of queryItems) {
        const words = wordsFromNode(item, nodeToHitType(item));
        if (words)
            for (const word of words)
                bag.register(word);
    }
    for (const word of bag.objects.values())
        word.enqueueInsert({ recursive: true });
    return bag;
}
class ExtractRepresentations_ExtractRepresentations extends HTMLProcessor_HTMLProcessor {
    ro() { return false; }
    async applyToDOM(dom, time) {
        const resource = new ResourceURL["ResourceURL"](dom.window.location.toString());
        const bag = getBagOfWords(dom);
        const binaryBag = bag.toBinaryBag();
        await Promise.all([
            resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].BAG_OF_WORDS, bag.toBuffer()),
            resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].BINARY_BAG_OF_WORDS, binaryBag.toBuffer()),
        ]);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_HTML_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].BAG_OF_WORDS_FILE, ResourceVersionType["ResourceVersionType"].BINARY_BAG_OF_WORDS_FILE]);
    }
}

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(3);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: ./dist/main/file.js
var main_file = __webpack_require__(18);

// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__(24);

// EXTERNAL MODULE: ./dist/main/types/GenericConstructor.js
var GenericConstructor = __webpack_require__(71);

// EXTERNAL MODULE: external "readline"
var external_readline_ = __webpack_require__(77);
var external_readline_default = /*#__PURE__*/__webpack_require__.n(external_readline_);

// EXTERNAL MODULE: ./dist/main/types/objects/WordVector.js
var WordVector = __webpack_require__(51);

// CONCATENATED MODULE: ./dist/main/types/WordVectors.js






class WordVectors_WordVectors extends GenericConstructor["a" /* GenericConstructor */] {
    toString() {
        let s = "";
        for (const id of [...this.vectors.keys()].sort(util["a" /* CMP_BIG_INT */])) {
            s += `${id}`.padStart(29, "0") + " ";
            s += " " + this.vectors.get(id).vector.value.toString("base64");
            s += "\n";
        }
        return s;
    }
    async toBuffer() {
        const file = Object(main_file["e" /* randomBufferFile */])();
        const dst = external_fs_default.a.createWriteStream(file);
        const ids = [...this.vectors.keys()].sort(util["a" /* CMP_BIG_INT */]);
        for (const id of ids) {
            const vector = this.vectors.get(id);
            dst.write(Object(util["k" /* writeBigUInt96BE */])(id));
            dst.write(vector.vector.value);
        }
        dst.end();
        await new Promise(res => dst.on("finish", res));
        return file;
    }
    static async fromPath(path, source) {
        return this.fromStream(external_fs_default.a.createReadStream(path), source);
    }
    static async fromStream(input, source) {
        const readInterface = external_readline_default.a.createInterface({ input });
        const vectors = new Map();
        let firstRowParsed = false;
        let words;
        let dimensions;
        readInterface.on("line", line => {
            if (firstRowParsed) {
                const vector = WordVector["WordVector"].fromString(line, source);
                const wordID = vector.word.getID();
                vectors.set(wordID, vector);
            }
            else {
                const parts = line.match("^([0-9]+) ([0-9]+)$");
                if (parts) {
                    firstRowParsed = true;
                    words = parseInt(parts[1]);
                    dimensions = parseInt(parts[2]);
                }
                else {
                    const vector = WordVector["WordVector"].fromString(line, source);
                    const wordID = vector.word.getID();
                    vectors.set(wordID, vector);
                }
            }
        });
        await new Promise(res => readInterface.on("close", res));
        if (vectors.size === 0)
            throw new Error(`missing data in file: ${words}`);
        for (const [wordID, vector] of vectors.entries())
            if (vector.vector.value.length !== dimensions * WordVector["BYTES_PER_FLOAT"])
                throw new Error(`invalid dimensions for wordID: ${wordID}`);
        return new WordVectors_WordVectors({ vectors });
    }
}

// EXTERNAL MODULE: ./dist/main/common/SQL.js
var SQL = __webpack_require__(12);

// EXTERNAL MODULE: ./dist/main/types/objects/Vector.js
var Vector = __webpack_require__(32);

// CONCATENATED MODULE: ./dist/main/services/resource-processor/ExtractWordVectorsFromSource.js










const UNZIP = "unzip";
class ExtractWordVectorsFromSource_ExtractWordVectorsFromSource extends ResourceProcessor {
    ro() { return true; }
    async apply(resource, input, time) {
        console.log(resource.getID());
        const compressedTMP = Object(main_file["e" /* randomBufferFile */])();
        console.log(compressedTMP);
        const outputStream = external_fs_default.a.createWriteStream(compressedTMP);
        const inputStream = await resource.stream(time, ResourceVersionType["ResourceVersionType"].RAW_ZIP);
        console.log({ inputStream: !!inputStream });
        inputStream.pipe(outputStream);
        await new Promise(res => {
            outputStream.on("close", async () => {
                console.log("write complete");
                const lsOutput = (await Object(util["h" /* spawnPromise */])(() => Object(external_child_process_["spawn"])(UNZIP, ["-l", compressedTMP]))).toString();
                const path = lsOutput
                    .split("\n")
                    .map(line => line.match(/[^ ]+.vec$/))
                    .filter(notNull => notNull)
                    .map(match => match[0])[0];
                Object(util["e" /* fancyLog */])(path);
                const inputStream = Object(external_child_process_["spawn"])(UNZIP, ["-p", compressedTMP, path]).stdout;
                Object(util["e" /* fancyLog */])("spawned");
                const wordVectors = await WordVectors_WordVectors.fromStream(inputStream, resource);
                Object(util["e" /* fancyLog */])(`vectors: ${wordVectors.vectors.size}`);
                const tmpFile = await wordVectors.toBuffer();
                Object(util["e" /* fancyLog */])("created buffer " + tmpFile);
                let stream = external_fs_default.a.createReadStream(tmpFile);
                try {
                    await resource.writeVersion(time, ResourceVersionType["ResourceVersionType"].WORD_EMBEDDINGS, stream);
                }
                catch (e) {
                    Object(util["e" /* fancyLog */])("error writing word embedding file:");
                    Object(util["e" /* fancyLog */])(JSON.stringify(e));
                }
                try {
                    Object(util["e" /* fancyLog */])("wrote embeddings to file for " + resource.getID());
                    const fd = external_fs_default.a.openSync(tmpFile, "r");
                    const CHUNK_SIZE = 612;
                    const buffer = Buffer.alloc(CHUNK_SIZE);
                    const vectorCSV = Object(main_file["e" /* randomBufferFile */])();
                    const wordVectorCSV = Object(main_file["e" /* randomBufferFile */])();
                    const vectorCSVWrite = external_fs_default.a.createWriteStream(vectorCSV);
                    const wordVectorCSVWrite = external_fs_default.a.createWriteStream(wordVectorCSV);
                    const finish = Promise.all([
                        new Promise(res => vectorCSVWrite.on("finish", res)),
                        new Promise(res => wordVectorCSVWrite.on("finish", res)),
                    ]);
                    Object(util["e" /* fancyLog */])("writing CSV");
                    Object(util["e" /* fancyLog */])(JSON.stringify({ vectorCSV, wordVectorCSV }));
                    const sourceID = resource.getID();
                    let lines = 0;
                    for (let read = external_fs_default.a.readSync(fd, buffer, 0, CHUNK_SIZE, null); read > 0; read = external_fs_default.a.readSync(fd, buffer, 0, CHUNK_SIZE, null)) {
                        if (!(lines & 0b1111111111111))
                            Object(util["e" /* fancyLog */])(JSON.stringify({ lines: lines, read }));
                        lines++;
                        const id = Object(util["c" /* bytesToBigInt */])(buffer.slice(0, 12));
                        const tail = buffer.slice(12, buffer.length);
                        const vector = new Vector["Vector"](tail);
                        const vectorID = vector.getID();
                        const vectorRow = SQL["b" /* SQL */].csvRow([vectorID, vector.value]);
                        const wordVectorRow = SQL["b" /* SQL */].csvRow([id, sourceID, vectorID]);
                        vectorCSVWrite.write(vectorRow + "\n");
                        wordVectorCSVWrite.write(wordVectorRow + "\n");
                    }
                    Object(util["e" /* fancyLog */])("closing read stream");
                    external_fs_default.a.closeSync(fd);
                    Object(util["e" /* fancyLog */])("ending write stream.");
                    vectorCSVWrite.end();
                    wordVectorCSVWrite.end();
                    Object(util["e" /* fancyLog */])("awaiting finish");
                    await finish;
                    Object(util["e" /* fancyLog */])("bulk insert word vec CSV");
                    await new WordVector["WordVector"]().bulkInsert(wordVectorCSV);
                    Object(util["e" /* fancyLog */])("bulk insert vector CSV");
                    await new Vector["Vector"]().bulkInsert(vectorCSV);
                    Object(util["e" /* fancyLog */])("cleanup");
                    external_fs_default.a.unlinkSync(tmpFile);
                    external_fs_default.a.unlinkSync(compressedTMP);
                    external_fs_default.a.unlinkSync(vectorCSV);
                    external_fs_default.a.unlinkSync(wordVectorCSV);
                    res();
                }
                catch (e) {
                    Object(util["e" /* fancyLog */])(JSON.stringify(e));
                    res();
                }
            });
            outputStream.on("error", e => {
                Object(util["e" /* fancyLog */])(JSON.stringify(e));
                external_fs_default.a.unlinkSync(compressedTMP);
                res();
            });
        });
        console.log("Done.");
    }
    hosts() {
        return new Set(["dl.fbaipublicfiles.com"]);
    }
    from() {
        return new Set([ResourceVersionType["ResourceVersionType"].RAW_ZIP_FILE]);
    }
    to() {
        return new Set([ResourceVersionType["ResourceVersionType"].WORD_EMBEDDINGS_FILE]);
    }
}

// CONCATENATED MODULE: ./dist/main/services/resource-processor/worker.js










const worker_process = buildProcessFunction([ExtractAHrefs_ExtractAHrefs, ExtractTitle_ExtractTitle, ExtractWikiTree_ExtractWikiTree, ExtractRawText_ExtractRawText, ExtractHits_ExtractHits, ExtractRepresentations_ExtractRepresentations, ExtractWordVectorsFromSource_ExtractWordVectorsFromSource].map(c => new c()));
Object(worker["a" /* start */])(worker_process, events["k" /* HTML_PROCESS_BIRTH_LOG */], events["m" /* HTML_PROCESS_DEATH_LOG */], null, events["l" /* HTML_PROCESS_COMPLETE */]);


/***/ })
/******/ ]);